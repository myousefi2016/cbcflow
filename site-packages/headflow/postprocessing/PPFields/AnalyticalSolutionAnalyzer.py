
from .ppfieldbase import PPFieldBase
import dolfin # TODO: Use headflow.dol instead
from math import sqrt 

class AnalyticalSolutionAnalyzer(PPFieldBase): 
    def __init__(self, **kwargs):
        PPFieldBase.__init__(self, **kwargs)

    def update(self, u, p, t, timestep, problem): 
        u_anal, p_anal = problem.analytical_solution(t) 
        u0_error = sqrt(dolfin.assemble(pow(u_anal[0] - u[0], 2)*problem.dx()))
        u1_error = sqrt(dolfin.assemble(pow(u_anal[1] - u[1], 2)*problem.dx()))
        u2_error = sqrt(dolfin.assemble(pow(u_anal[2] - u[2], 2)*problem.dx()))
        c = dolfin.assemble((p_anal-p)*dolfin.dx) / dolfin.assemble(dolfin.Constant(1)*dolfin.dx, mesh=p.function_space().mesh())  
        p.vector()[:] += c  
        p_error = dolfin.errornorm (p_anal, p)
        p_dx     = dolfin.assemble(p*dolfin.dx)
        p_anal_dx     = dolfin.assemble(p_anal*dolfin.dx, mesh=p.function_space().mesh())
        self.set_data(t, timestep, {"u0" : u0_error, "u1": u1_error, "u2": u2_error, "p": p_error, "pdx": p_dx, "analytical_pdx" : p_anal_dx})
        print "t ", t, " error (u0, u1, u2, p, pdx, analytical_pdx) ", u0_error, u1_error, u2_error, p_error, p_dx, p_anal_dx  


