
from fractions import gcd
from os.path import isfile, isdir, join
from os import listdir, makedirs

from ...dol import Function, File, MPI

from ...core.paramdict import ParamDict
from ...core.parameterized import Parameterized

class PPFieldBase(Parameterized):
    def __init__(self, parent=None, params=None):
        Parameterized.__init__(self, params)

        self._savefolder = '.'
        self._save_count = -1

        self.update_count = 0

        self._datadict = {"timestep": 0, "time":0.0, "data": None}

        # TODO: [martin] I instinctively don't like that the field changes the parameters of the parent,
        #       but maybe I need to read it again to understand what this is trying to accomplish
        # Set and update parent
        self._set_parent(parent)

    # --- Parent meddling functions ---

    def _set_parent(self, parent):
        self.parent = parent
        params = self.params
        if parent != None:
            for k in self.params.timeparams:
                if k not in parent.params.timeparams:
                    continue
                #import pdb; pdb.set_trace()

                if k == "start_timestep" or k == "start_time":
                    parent.params.timeparams[k] = min(parent.params.timeparams[k], params.timeparams[k])
                elif k == "end_timestep" or k == "end_time":
                    parent.params.timeparams[k] = max(parent.params.timeparams[k], params.timeparams[k])

                #continue
                # TODO: FIXME
                '''
                elif "_frequency" in k:

                    a = parent.params[k]
                    b = params[k]
                    #import pdb; pdb.set_trace()
                    if isinstance(a, int) and isinstance(b, int):
                        print "integers", a, b, gcd(a,b)
                        parent.params[k] = gcd(a,b)
                    else:
                        print "non integers", a, b
                        C = 1e10
                        aa = int(a*C)
                        bb = int(b*C)
                        parent.params[k] = 1.0*gcd(aa, bb)/C
                    #print k

                    if "step" in k:
                        #print k
                        print parent.params["start_timestep"], parent.params[k], params["start_timestep"], params[k]
                        print parent.params["start_timestep"]%parent.params[k], params["start_timestep"]%parent.params[k]
                        while parent.params["start_timestep"]%parent.params[k] != params["start_timestep"]%parent.params[k]: #and parent.params[k] > 1:
                            #params["start_timestep"] -= 1
                            #print parent.params["start_timestep"]
                            print parent.params[k]
                            parent.params[k] -= 1
                    '''

    def _adjust_parent_instance(self, prop, change_condition):
        if self.parent is None:
            return
        if change_condition(getattr(self, prop), getattr(self.parent, prop)):
            #setattr(self.parent, prop, getattr(self, prop)) # TODO?
            exec("self.parent.%s = self.%s" %(prop, prop))

    # --- Parameter handling ---

    @classmethod
    def default_base_params(cls):
        "The base class can overload this to add generic parameters."
        params = ParamDict(
            timeparams = ParamDict(
                start_timestep=0,
                end_timestep = 1e16,
                start_time = 0.0,
                end_time = 1e16,
                step_frequency = 1,
                time_frequency = 1e-16,
                ),
            saveparams = ParamDict(
                save = False,
                saveformat = 'determined by data', # Supported: 'xml', 'xml.gz', 'pvd', 'txt'
                #savetime = 'all', # To be supported: 'all', 'end', 'start'
                )
            )
        return params

    # --- Folder saving stuff ---

    @property
    def savefolder(self):
        return self._savefolder

    @savefolder.setter
    def savefolder(self, casedir):
        if self.params.saveparams.save:
            folder = self.__class__.__name__
            self._savefolder = join(casedir, folder)

            if MPI.process_number() == 0:
                if not isdir(self._savefolder):
                    makedirs(self._savefolder)
                elif listdir(self._savefolder) != []:
                    # TODO: Should this be an error? Or should perhaps all content of folder be deleted?
                    # TODO: Fix headflow warning
                    from warnings import warn
                    warn("Directory %s exists and is non-empty" %self._savefolder)

    # --- Updating interface ---

    def before_first_update(self, u, p, t, timestep, problem):
        pass

    def after_last_update(self, u, p, t, timestep, problem):
        pass

    def firstrun(self, u, p, t, timestep, problem):
        pass

    def update(self, u, p, t, timestep, problem):
        raise NotImplementedError("update needs to be overridden in subclass.")

    # --- Data handling ---
    def set_data(self, t, timestep, data):
        self._datadict["time"] = t
        self._datadict["timestep"] = timestep
        self._datadict["data"] = data

        if self.params.saveparams.save:
            # TODO: Add conditions based on self.params.saveparams.savetime
            self._save_data()

    def get_data(self):
        return self._datadict

    def _save_data(self):
        # Update save count
        self._save_count += 1

        # Get data
        datadict = self.get_data()
        data = datadict["data"]

        # Logic for first save call
        if self._save_count == 0:
            metadata_file = open(join(self._savefolder, 'metadata.txt'), 'w')

            # Determine proper output if not specifically provided
            if self.params.saveparams.saveformat == PPFieldBase.default_params().saveparams.saveformat:
                if isinstance(data, (float, list, dict, int)):
                    self.params.saveparams.saveformat = 'txt'
                elif isinstance(data, Function):
                    self.params.saveparams.saveformat = ['pvd', 'xml.gz']

            self._savefiles = {}
            # Get datatype
            self._datatype = type(data)
            if self._datatype == dict:
                self._identifiers = data.keys()
            if self._datatype == Function:
                if 'pvd' in self.params.saveparams.saveformat:
                    self._savefiles['pvd'] = File(join(self._savefolder, "data.pvd"))
                if 'xdmf' in self.params.saveparams.saveformat:
                    self._savefiles['xdmf'] = File(join(self._savefolder, "data.xdmf"))


            # Write initial metadata
            metadata_file.write('saveformat: %s\n' %self.params.saveparams.saveformat)
            if hasattr(self, "_identifiers"):
                metadata_file.write("identifiers: ")
                [metadata_file.write("%s " %k) for k in self._identifiers]
                metadata_file.write("\n")
            metadata_file.write('#####################################\n')

        else:
            metadata_file = open(join(self._savefolder, 'metadata.txt'), 'a')


        # Verify that data type has not changed
        assert(isinstance(data, self._datatype))


        # Make saveformat parameters iterable (in case there are several)
        if not isinstance(self.params.saveparams.saveformat, list):
            self.params.saveparams.saveformat = [self.params.saveparams.saveformat]


        for saveformat in self.params.saveparams.saveformat:
            metadata = []
            #Write data
            if saveformat == 'txt':
                # TODO: Refine write process
                datafile = open(join(self.savefolder, "data.txt"), 'a')
                datafile.write(str(data)+"\n")
                datafile.close()

            elif saveformat == 'xml' or saveformat == 'xml.gz':
                filename = "data%d.%s" %(self._save_count, saveformat)
                metadata.append(('filename', filename))
                File(join(self._savefolder, filename)) << data

            elif saveformat == 'pvd':
                self._savefiles['pvd'] << data

            elif saveformat == 'xdmf':
                self._savefiles['xdmf'] << (data, datadict["time"])

            # Write metadata

            metadata.append(self._save_count)
            metadata.append(('timestep', datadict['timestep']))
            metadata.append(('time', datadict['time']))
            for md in metadata:
                if isinstance(md, tuple):
                    metadata_file.write("%s=%s" %(md[0], md[1]))
                else:
                    metadata_file.write("%s" %md)
                metadata_file.write('\t')
            metadata_file.write('\n')

        metadata_file.close()
