from headflow import *
import operator
from fractions import gcd

class PPFieldBase(object):
    def __init__(self, parent=None, params=None):
        
        # Store parameters
        self.params = self.default_params()
        self.params.update_recursive(params)

        self._datadict = {"timestep": 0, "time":0.0, "data": None}

        # Set and update parent
        self.parent = parent
        if self.parent != None:
            for k in params:
                if k not in parent.params:
                    continue
                
                if "start_" in k:
                    parent.params[k] = min(parent.params[k], params[k])
                elif "end_" in k:
                    parent.params[k] = max(parent.params[k], params[k])
                continue
                # TODO: FIXME
                '''
                elif "_frequency" in k:
                    
                    a = parent.params[k]
                    b = params[k]
                    #import pdb; pdb.set_trace()
                    if isinstance(a, int) and isinstance(b, int):
                        print "integers", a, b, gcd(a,b)
                        parent.params[k] = gcd(a,b)
                    else:
                        print "non integers", a, b
                        C = 1e10
                        aa = int(a*C)
                        bb = int(b*C)
                        parent.params[k] = 1.0*gcd(aa, bb)/C
                    #print k
                    
                    if "step" in k:
                        print k
                        print parent.params["start_timestep"]%parent.params[k], params["start_timestep"]%params[k]
                        while parent.params["start_timestep"]%parent.params[k] != params["start_timestep"]%params[k]:
                            print parent.params["start_timestep"]
                            parent.params["start_timestep"] -= 1
                '''
                            
                        
                    

    @classmethod
    def default_problem_params(cls):
        "Subclasses should implement this to define problem specific parameters."
        return {}

    @classmethod
    def default_params(cls):
        params = ParamDict(
            start_timestep=-1,
            end_timestep = 1e16,
            start_time = -1.0,
            end_time = 1e16,
            step_frequency = 1,
            time_frequency = 1e-16,            
        )
        params.update_recursive(cls.default_problem_params())
        return params

    ### Data handling
    def set_data(self, t, timestep, data):
        self._datadict["time"] = t
        self._datadict["timestep"] = timestep
        self._datadict["data"] = data

    def get_data(self):
        return self._datadict

    ### Help functions
    def _adjust_parent_instance(self, prop, change_condition):
        if self.parent == None:
            return
        if change_condition(getattr(self, prop), getattr(self.parent, prop)):
            #setattr(self.parent, prop, getattr(self, prop)) # TODO?
            exec("self.parent.%s = self.%s" %(prop, prop))

    '''
    DEPRECATED
    '''
    '''
    # FIXME: Make properties share getters and setters
    ### Properties: start*
    @property
    def start_timestep(self):
        return self._start_timestep

    @start_timestep.setter
    def start_timestep(self, value):
        if self._start_timestep == -1 or value < self._start_timestep:
            self._start_timestep = value

        self._adjust_parent_instance("start_timestep", operator.lt)

    @property
    def start_time(self):
        return self._start_time

    @start_time.setter
    def start_time(self, value):
        if self._start_time == -1 or value < self._start_time:
            self._start_time = value
        self._adjust_parent_instance("start_time", operator.lt)

    ### Properties: end*
    @property
    def end_timestep(self):
        return self._end_timestep

    @end_timestep.setter
    def end_timestep(self, value):
        if self.end_timestep == 1e16 or value > self.end_timestep:
            self._end_timestep = value
        self._adjust_parent_instance("end_timestep", operator.gt)

    @property
    def end_time(self):
        return self._end_time

    @end_time.setter
    def end_time(self, value):
        if self.end_time == 1e16 or value > self.end_time:
            self._end_time = value

        self._adjust_parent_instance("end_time", operator.gt)
    '''

