
from ...dol import Function, File

from headflow import * # FIXME: This is not nice, import what's needed instead

#import operator
#from fractions import gcd

from os.path import isfile, isdir, join
from os import listdir, makedirs

class PPFieldBase(object):
    def __init__(self, parent=None, params=None, timeparams=None, saveparams=None):
        
        # Store parameters
        self.params = self.default_params()
        self.params.update_recursive(params)
        self.params.timeparams.update_recursive(timeparams)
        self.params.saveparams.update_recursive(saveparams)
        
        self._savefolder = '.'
        
        self._save_count = -1        

        self._datadict = {"timestep": 0, "time":0.0, "data": None}

        # Set and update parent
        self.parent = parent
        if self.parent != None:
            for k in self.params.timeparams:
                if k not in parent.params.timeparams:
                    continue
                #import pdb; pdb.set_trace()
                
                if k == "start_timestep" or k == "start_time":
                    parent.params.timeparams[k] = min(parent.params.timeparams[k], self.params.timeparams[k])
                elif k == "end_timestep" or k == "end_time":
                    parent.params.timeparams[k] = max(parent.params.timeparams[k], self.params.timeparams[k])
                #continue
                # TODO: FIXME
                '''
                elif "_frequency" in k:
                    
                    a = parent.params[k]
                    b = params[k]
                    #import pdb; pdb.set_trace()
                    if isinstance(a, int) and isinstance(b, int):
                        print "integers", a, b, gcd(a,b)
                        parent.params[k] = gcd(a,b)
                    else:
                        print "non integers", a, b
                        C = 1e10
                        aa = int(a*C)
                        bb = int(b*C)
                        parent.params[k] = 1.0*gcd(aa, bb)/C
                    #print k
                    
                    if "step" in k:
                        #print k
                        print parent.params["start_timestep"], parent.params[k], params["start_timestep"], params[k]
                        print parent.params["start_timestep"]%parent.params[k], params["start_timestep"]%parent.params[k]
                        while parent.params["start_timestep"]%parent.params[k] != params["start_timestep"]%parent.params[k]: #and parent.params[k] > 1:
                            #params["start_timestep"] -= 1
                            #print parent.params["start_timestep"]
                            print parent.params[k]
                            parent.params[k] -= 1
                            
                    '''
                            
                        
                    

    @classmethod
    def default_problem_params(cls):
        "Subclasses should implement this to define problem specific parameters."
        return {}

    @classmethod
    def default_params(cls):
        params = ParamDict(
            timeparams = ParamDict(
                start_timestep=0,
                end_timestep = 1e16,
                start_time = 0.0,
                end_time = 1e16,
                step_frequency = 1,
                time_frequency = 1e-16,
                ),
            saveparams = ParamDict(
                save = False,
                saveformat = 'determined by data', # Supported: 'xml', 'xml.gz', 'pvd', 'txt'
                #savetime = 'all', # To be supported: 'all', 'end', 'start'
            )
            )
        params.update_recursive(cls.default_problem_params())
        return params


    @property
    def savefolder(self):
        return self._savefolder
    
    @savefolder.setter
    def savefolder(self, casedir):
        if self.params.saveparams.save:
            folder = self.__class__.__name__
            self._savefolder = join(casedir, folder)
            
            if not isdir(self._savefolder):
                makedirs(self._savefolder)
            elif listdir(self._savefolder) != []:
                # TODO: Should this be an error? Or should perhaps all content of folder be deleted?
                # TODO: Fix headflow warning
                from warnings import warn
                warn("Directory %s exists and is non-empty" %self._savefolder)
                
  

    ### Data handling
    def set_data(self, t, timestep, data):
        self._datadict["time"] = t
        self._datadict["timestep"] = timestep
        self._datadict["data"] = data
        
        if self.params.saveparams.save:
            # TODO: Add conditions based on self.params.saveparams.savetime
            self._save_data()

    def get_data(self):
        return self._datadict
    
    def _save_data(self):
        # Update save count
        self._save_count += 1
        
        # Get data
        datadict = self.get_data()
        data = datadict["data"]

        # Logic for first save call
        if self._save_count == 0:
            metadata_file = open(join(self._savefolder, 'metadata.txt'), 'w')
            
            # Determine proper output if not specifically provided
            if self.params.saveparams.saveformat == PPFieldBase.default_params().saveparams.saveformat:    
                if isinstance(data, (float, list, dict, int)):
                    self.params.saveparams.saveformat = 'txt'
                elif isinstance(data, Function):
                    self.params.saveparams.saveformat = ['pvd', 'xml.gz']
            
            self._savefiles = {}
            # Get datatype
            self._datatype = type(data)
            if self._datatype == dict:
                self._identifiers = data.keys()
            if self._datatype == Function:
                if 'pvd' in self.params.saveparams.saveformat:
                    self._savefiles['pvd'] = File(join(self._savefolder, "data.pvd"))

                      
            # Write initial metadata
            metadata_file.write('saveformat: %s\n' %self.params.saveparams.saveformat)
            if hasattr(self, "_identifiers"):
                metadata_file.write("identifiers: ")
                [metadata_file.write("%s " %k) for k in self._identifiers]
                metadata_file.write("\n")
            metadata_file.write('#####################################\n')
            
        else:
            metadata_file = open(join(self._savefolder, 'metadata.txt'), 'a')
            
           
        
        # Verify that data type has not changed
        assert(isinstance(data, self._datatype))

        
        # Make saveformat parameters iterable (in case there are several)
        if not isinstance(self.params.saveparams.saveformat, list):
            self.params.saveparams.saveformat = [self.params.saveparams.saveformat]
        
        
        for saveformat in self.params.saveparams.saveformat:
            #Write data
            if saveformat == 'txt':               
                # TODO: Refine write process    
                datafile = open(join(self.savefolder, "data.txt"), 'a')
                datafile.write(str(data)+"\n")
                datafile.close()
                
            elif saveformat == 'xml' or saveformat == 'xml.gz':
                filename = "data%d.%s" %(self._save_count, saveformat)
                metadata.append(('filename', filename))
                File(join(self._savefolder, filename)) << data
                
            elif saveformat == 'pvd':
                self._savefiles['pvd'] << data
                
            # Write metadata
            metadata = []
            metadata.append(self._save_count)
            metadata.append(('timestep', datadict['timestep']))
            metadata.append(('time', datadict['time']))
            for md in metadata:
                if isinstance(md, tuple):
                    metadata_file.write("%s=%s" %(md[0], md[1]))
                else:
                    metadata_file.write("%s" %md)
                metadata_file.write('\t')
            metadata_file.write('\n')
            
        metadata_file.close()    


    ### Help functions
    def _adjust_parent_instance(self, prop, change_condition):
        if self.parent == None:
            return
        if change_condition(getattr(self, prop), getattr(self.parent, prop)):
            #setattr(self.parent, prop, getattr(self, prop)) # TODO?
            exec("self.parent.%s = self.%s" %(prop, prop))
            
    def update(self, u, p, t, timestep):
        raise NotImplementedError("update needs to be overridden in subclass.")
