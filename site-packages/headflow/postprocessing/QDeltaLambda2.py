
from .ppfield import PPField

from dolfin import FunctionSpace, TrialFunction, TestFunction, Function, grad, det

class QDeltaLambda2(PPField):
    def __init__(self, **kwargs):
        PPField.__init__(self, **kwargs)

    #def before_first_compute(self, u, p, t, timestep, problem):
    def before_first_compute(self, pp, problem):
        dx = problem.dx

        # TODO: Get spaces as input here, avoid allocating this additional space
        self.scalar_space = FunctionSpace(problem.mesh, "CG", 1) #maybe use DG to get it more efficient

        self.Q = Function(self.scalar_space, name="Q")
        self.Delta = Function(self.scalar_space, name="Delta")
        self.Lambda2 = Function(self.scalar_space, name="Lambda2")

        self.u = TrialFunction(self.scalar_space)
        self.v = TestFunction(self.scalar_space)

        self.m = self.u*self.v*dx()   

    #def compute(self, u, p, t, timestep, problem):
    def compute(self, pp, problem):
        dx = problem.dx
        
        u = pp.get("Velocity")
        
        S = (grad(u) + grad(u).T)/2
        Omega = (grad(u) - grad(u).T)/2  
        v = self.v

        self.LQ = Constant(0.5) * (Omega**2 - S**2)*v*dx()
        solve(self.m == self.LQ, self.Q)

        self.LDelta = (self.Q**3 / 3 + det(grad(u))**2 / 2 )*v*dx()    
        solve(self.m == self.LDelta, self.Delta) 

        self.LLambda2 = (Omega**2 + S**2)*v*dx() 
        solve(self.m == self.LLambda2, self.Lambda2) 

        data = { "Q" : self.Q, "Delta" : self.Delta, "Lambda2": self.Lambda2 }
        #self.set_data(t, timestep, data)
        return data

