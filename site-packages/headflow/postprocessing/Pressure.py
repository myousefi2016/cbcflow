from .PPField import PPField
from dolfin import Function, project, as_vector, Expression, assemble, solve, TestFunction, TrialFunction, dx, dot, KrylovSolver, cpp
from ..core.spaces import NSSpacePoolMixed, NSSpacePoolSplit, NSSpacePoolSegregated

class Pressure(PPField):
    def convert(self, pp, spaces, problem):
        # Hack to get given p in whatever format it has
        p = super(Pressure, self).convert(pp, spaces, problem)

        # TODO: Should we scale p by density here so we get the physical pressure in postprocessing?
        #       Or by a factor provided by the scheme?
        #       However the problem interface relates to the scaled pressure,
        #       as well as e.g. restarting. Maybe add a PhysicalPressure field with proper scaling?

        # Convert p into a Function if the scheme is mixed
        #if isinstance(spaces, NSSpacePoolSplit):
        #elif isinstance(spaces, NSSpacePoolMixed):
        #elif isinstance(spaces, NSSpacePoolSegregated):

        if not isinstance(p, Function):
            # Reusing projection matrix and solver, mixedfunction->scalarfunction assign with be better TODO
            if not hasattr(self, "_p"):
                self._p = Function(spaces.Q)
                self._te = TestFunction(spaces.Q)
                self._tr = TrialFunction(spaces.Q)
                self._a = dot(self._tr,self._te)*dx()
                L = dot(p, self._te)*dx()
                self._A = assemble(self._a)
                self._b = assemble(L)
                self._solver = KrylovSolver("cg", "default")
                self._solver.set_operator(self._A)
            else:
                L = dot(p, self._te)*dx()
                assemble(L, tensor=self._b)
            self._solver.solve(self._p.vector(), self._b)
            p = self._p

        assert isinstance(p, Function)
        return p
