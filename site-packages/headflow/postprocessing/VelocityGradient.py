from .ppfield import PPField
from dolfin import *

class VelocityGradient(PPField):
    def __init__(self, params=None):
        PPField.__init__(self, params)

    def before_first_compute(self, pp, problem):
        if self.params.assemble:
            # TODO: Replace with spaces
            DG = TensorFunctionSpace(problem.mesh, "DG", 0)
            self.v = TestFunction(DG)
            self.velocitygradient = Function(DG, name="VelocityGradient")

    def compute(self, pp, problem):
        u = pp.get("Velocity")

        if self.params.assemble:
            assemble(inner(grad(u), self.v)*dx, tensor=self.velocitygradient.vector())
            return self.velocitygradient
        else:
            return grad(u)


# Here's what it might look like to use a pool of spaces:

def assemble_cellwise_values(pp, expr): # TODO: Make a shared utility function of this
    "Assemble the values of expr into a piecewise constant function."
    shape = expr.shape()
    space = pp.space_pool.get_custom_space("DG", 0, shape)
    target = pp.function_pool.borrow_function(space)
    mesh = space.mesh()
    cell = mesh.ufl_cell()
    scale = 1.0/cell.volume
    test = TestFunction(space)
    dx = pp.dx()
    assemble(scale*inner(expr, test)*dx(), tensor=target.vector())
    return target

class AlternativeVelocityGradient(PPField):
    def __init__(self, params=None):
        PPField.__init__(self, params)

    def compute(self, pp, problem):
        # Get dependencies, should these always be functions?
        u = pp.get("Velocity")

        # Define ufl expression to compute
        expr = grad(u)

        # Need to figure out how much we should control the return format.
        if self.params.assemble:
            return assemble_cellwise_values(pp, expr)
        elif self.params.project:
            DV = pp.space_pool.get_custom_space("DG", 0, expr.shape())
            return project(expr, DV)
        else:
            return expr
