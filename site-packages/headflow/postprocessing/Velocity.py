from .PPField import PPField
from dolfin import Function, project, as_vector, Expression, assemble, solve, TestFunction, TrialFunction, dx, dot, KrylovSolver, cpp
from ..core.spaces import NSSpacePoolMixed, NSSpacePoolSplit, NSSpacePoolSegregated

class Velocity(PPField):
    def convert(self, pp, spaces, problem):
        # Hack to get given u in whatever format it has,
        # avoiding circular reference to this field
        u = super(Velocity, self).convert(pp, spaces, problem)

        # Convert u into a Function if the scheme is segregated or mixed
        #if isinstance(spaces, NSSpacePoolSplit):
        #elif isinstance(spaces, NSSpacePoolMixed):
        #elif isinstance(spaces, NSSpacePoolSegregated):

        if not isinstance(u, Function):
            # Reusing projection matrix and solver, subfunction->vectorfunction assign with be better TODO
            if not hasattr(self, "_u"):
                self._u = Function(spaces.V)
                self._te = TestFunction(spaces.V)
                self._tr = TrialFunction(spaces.V)
                self._a = dot(self._tr,self._te)*dx()
                L = dot(u, self._te)*dx()
                self._A = assemble(self._a)
                self._b = assemble(L)
                self._solver = KrylovSolver("cg", "default")
                self._solver.set_operator(self._A)
            else:
                L = dot(u, self._te)*dx()
                assemble(L, tensor=self._b)
            self._solver.solve(self._u.vector(), self._b)
            u = self._u

        assert isinstance(u, Function)

        return u
