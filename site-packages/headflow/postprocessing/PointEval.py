from .MetaPPField import MetaPPField
from ..utils import *
import numpy as np
from dolfin import Point

# FIXME: This concept will fail if the user adds more than one PointEval for a given field
class PointEval(MetaPPField):
    def __init__(self, value, points, params=None):
        MetaPPField.__init__(self, value, params)
        self.points = points

    def before_first_compute(self, pp, spaces, problem):
        u = pp.get(self.valuename)

        V = u.function_space()
        dim = V.mesh().geometry().dim()

        self.coords = []
        for p in self.points:
            if isinstance(p, Point):
                pt = tuple((p.x(), p.y(), p.z())[:dim])
            else:
                pt = tuple(p)
            assert len(pt) == dim
            self.coords.append(pt)
        self.coords = tuple(self.coords)

        pointlist = []
        for pt in self.coords:
            pointlist.extend(pt)
        self.probes = Probes(np.array(pointlist), V)

        # This is really not necessary?
        self.accumulated_results = {}

        self._first = 1

    def compute(self, pp, spaces, problem):
        u = pp.get(self.valuename)
        self.probes.eval(u)
        results = self.probes.array()

        if results is None:
            # Not on master node so probes give us no data.
            # Return dummy dict which is not used by postprocessor anyway.
            return {}

        # This is really not necessary?
        for i, pt in enumerate(self.coords):
            self.accumulated_results[pt] = results[i]

        # Hack for first timestep because of inconsistent
        # shape len from probe results
        if self._first:
            self._first = 0
            results_this_timestep = results[...]
        else:
            results_this_timestep = results[...,-1]

        # Returning points and values each timestep, this is really superfluous
        #return (self.coords, results_this_timestep)
        return dict((x,v) for (x,v) in zip(self.coords, results_this_timestep))
