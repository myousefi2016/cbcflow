def update_check(ppfield, t, timestep):
    datadict = ppfield.get_data()

    if ppfield.params.timeparams.start_timestep > timestep or timestep > ppfield.params.timeparams.end_timestep:
        return False

    if ppfield.params.timeparams.start_time > t or t > ppfield.params.timeparams.end_time:
        return False

    if timestep-datadict["timestep"] < ppfield.params.timeparams.step_frequency:
        return False

    if t-datadict["time"] < ppfield.params.timeparams.time_frequency:
        return False

    # Else
    return True

class PostProcessorBase(object):
    def __init__(self, casedir=''):
        self.casedir = casedir
        self.list_all = []
        
    @classmethod
    def default_problem_params(cls):
        "Subclasses should implement this to define problem specific parameters."
        return {}

    @classmethod
    def default_params(cls):
        # TODO: Store with structure params.common.* and params.specific.* or similar?
        params = ParamDict()
        params.update_recursive(cls.default_problem_params())
        return params

    def update_all(self, u, p, t, timestep, problem):
        for field in self.list_all:
            if update_check(field, t, timestep):
                if field.update_count == 0:
                    field.before_first_update(u,p,t,timestep, problem)
                field.update(u,p,t,timestep, problem)
                field.update_count += 1
        
        
    def add_field(self, field):
        self.list_all.append(field)
        field.savefolder = self.casedir
        
    def add_fields(self, fields):
        for field in fields:
            self.add_field(field)
    
