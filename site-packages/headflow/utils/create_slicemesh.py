from dolfin import Mesh, Vertex, pi, Polygon, Point, MeshEditor
import numpy as np

def create_slicemesh(midpoint, v1, v2, delta1=1, delta2=1, refinement=20):
    '''Create slicemesh from a centerpoint, two (non-parallel vectors) of length delta1 and delta2.'''
    
    assert delta1 > 0, "delta1 needs to be greater than 0"
    assert delta2 > 0, "delta2 needs to be greater than 0"
    
    midpoint = np.array(midpoint, dtype=np.float64)
    v1 = np.array(v1, dtype=np.float64)
    v1 = v1/np.linalg.norm(v1)
    
    v2 = np.array(v2, dtype=np.float64)
    v2 = v2/np.linalg.norm(v2)
    
    # Check angle between vectors
    angle = np.arccos(np.dot(v1,v2))*180/pi
    if not 30 < angle < 150:
        #headflow_warning("Angle between vectors is small (%f). Could cause unexpected results from mesh generator." %angle)
        print "Angle between vectors is small (%f). Could cause unexpected results from mesh generator." %angle
    
    # Find plane (xy, yz, xz) plane "most" parallel to plane (this is gives the best mesh when projection is performed)
    normal = np.cross(v1, v2)
    normal = normal/np.linalg.norm(normal)
    
    xy_normal = np.array([0,0,1])
    yz_normal = np.array([1,0,0])
    xz_normal = np.array([0,1,0])
    
    plane_angles = []
    plane_angles.append(np.arccos(np.dot(normal, yz_normal)))
    plane_angles.append(np.arccos(np.dot(normal, xz_normal)))
    plane_angles.append(np.arccos(np.dot(normal, xy_normal)))
    
    project_axis = plane_angles.index(min(plane_angles))
    
    # Find corners
    corners = []
    
    corners.append(midpoint+delta1*v1)
    corners.append(midpoint+delta1*v2)
    corners.append(midpoint-delta1*v1)
    corners.append(midpoint-delta1*v2)
    
    # Project corners down into suitable plane
    projected_corners = []
    for c in corners:
        c = list(c)
        c.pop(project_axis)
        c = np.array(c, dtype=np.float64)
        projected_corners.append(c)
    
    
    def is_convex(corners):
        "Checks if given four points are convex in the current order"
        
        assert(len(corners) == 4), "Only supports 4 points"
        
        a = np.cross(corners[1]-corners[0], corners[2]-corners[1])
        b = np.cross(corners[2]-corners[1], corners[3]-corners[2])
        c = np.cross(corners[3]-corners[2], corners[0]-corners[3])
        d = np.cross(corners[0]-corners[3], corners[1]-corners[0])
        
        if a > 0 and b > 0 and c > 0 and d > 0:
            # Is convex
            return "Positives"
        elif a < 0 and b < 0 and c < 0 and d < 0:
            # Should be convex, but mesh generator  still complains
            return "Negatives"
        else:
            # Is not convex, points are in wrong order
            return "Wrong order"

    # Make sure corners define a convex set
    if is_convex(projected_corners) == "Negatives":
        # Reverse list
        projected_corners = list(reversed(projected_corners))
        corners = list(reversed(corners))
    elif is_convex(projected_corners) == "Wrong order":
        # Change order of list
        projected_corners[2], projected_corners[3] = projected_corners[3], projected_corners[2]
        corners[2], corners[3] = corners[3], corners[2]
    
    assert is_convex(projected_corners) == "Positives", "Unable to find a convex set of corners. Try to create slice with different parameters. %s" %(str(corners))
       

    # Transform polygon to unit square for easy evalution of projection value
    # First, find correct corner to transform from (rotate so that corners[0] is closest to the origin)
    distance_from_origin = [np.linalg.norm(p) for p in projected_corners]
    closest_point = distance_from_origin.index(min(distance_from_origin))
    projected_corners = projected_corners[closest_point:]+projected_corners[:closest_point]
    corners = corners[closest_point:]+corners[:closest_point]
    
    # Build transformation matrix (from unit square to polygon)
    x0, y0 = projected_corners[0]
    x1, y1 = projected_corners[3]
    x2, y2 = projected_corners[1]
    A = np.array([[x1-x0, x2-x0],[y1-y0, y2-y0]])
    Ainv = np.linalg.inv(A)
    
    # Create polygonmesh using projected corners
    polygon = Polygon([Point(*p) for p in projected_corners])
    projectedmesh = Mesh(polygon, refinement)
    
    # Transform mesh coordinates to unit square using the inverse
    for i, coords in enumerate(projectedmesh.coordinates()):
        projectedmesh.coordinates()[i,:] = np.dot(Ainv, coords - np.array([x0,y0]))
    
    
    # Create new mesh from projected mesh of correct dimensions
    slicemesh = Mesh()
    mesh_editor = MeshEditor()
    mesh_editor.open(slicemesh, "triangle", 2, 3)
    
    mesh_editor.init_vertices(projectedmesh.num_vertices())
    mesh_editor.init_cells(projectedmesh.num_cells())
    
    for index, cell in enumerate(projectedmesh.cells()):
        mesh_editor.add_cell(index, cell[0], cell[1], cell[2])
    
    for index in xrange(projectedmesh.num_vertices()):
        v = Vertex(projectedmesh, index)
        x,y = v.point().x(), v.point().y()
        
        # Get project value ("z"-value)
        project_value = corners[0][project_axis]*(1-x)*(1-y)
        project_value += corners[3][project_axis]*x*(1-y)
        project_value += corners[1][project_axis]*(1-x)*y
        project_value += corners[2][project_axis]*x*y
    
        # Transform back to polygon
        X,Y = np.dot(A, np.array([x,y]))+ + np.array([x0,y0])
        
        if project_axis == 0:
            vertexpoint = np.array([project_value, X, Y])
        elif project_axis == 1:
            vertexpoint = np.array([X, project_value, Y])
        elif project_axis == 2:
            vertexpoint = np.array([X, Y, project_value])
        
        mesh_editor.add_vertex_global(index, projectedmesh.topology().global_indices(0)[index], vertexpoint)
        
        
    mesh_editor.close()
    
    # Init global size
    slicemesh.topology().init_global(0, projectedmesh.topology().size_global(0))
    slicemesh.topology().init_global(2, projectedmesh.topology().size_global(2))
    
    return slicemesh