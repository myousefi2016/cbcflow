from __future__ import division

__author__ = "Oyvind Evju <oyvinev@simula.no>"
__date__ = "2013-04-30"
__copyright__ = "Copyright (C) 2013 " + __author__
__license__  = "GNU GPL version 3 or any later version"

from ..core.nsscheme import *
from ..core.utils import Timer, epsilon, sigma, is_periodic
from ..core.timesteps import compute_regular_timesteps

class CoupledNonLinear2(NSScheme):
    "Coupled scheme with fixed-point iterations on the convection term. NB: Direct solver!"

    def __init__(self, params):
        NSScheme.__init__(self, params, segregated=False)

    @classmethod
    def default_user_params(cls):
        params = ParamDict(
            theta=0.5, #0.5: Crank-Nicholson, 1.0: Backward Euler, 0.0: Forward Euler
            fixed_point_tolerance=1e-6,
            max_fixed_point_iterations=500,
            )
        return params

    def solve(self, problem, update, restart=None):
        # Get spatial parameters
        mesh = problem.mesh
        dx = problem.dx
        ds = problem.ds

        # Get time parameters
        dt, timesteps = compute_regular_timesteps(problem)
        t = Time(t0=timesteps[0])

        # Define function spaces
        V = VectorFunctionSpace(mesh, "CG", self.params.u_degree)
        Q = FunctionSpace(mesh, "CG", self.params.p_degree)
        W = V*Q

        # Test and trial functions
        v, q = TestFunctions(W)
        u, p = TrialFunctions(W)

        # Functions
        w0 = Function(W, name="w0")
        w1 = Function(W, name="w1")
        u0, p0 = split(w0)
        u1, p1 = split(w1)

        # Get control functions
        controls = problem.controls(V, Q)

        # Get initial conditions
        uinit, pinit = problem.initial_conditions(V, Q, controls)

        # Apply initial conditions
        w0.assign(project(as_vector(uinit + [pinit]), W))
        #assign(w0, uinit + [pinit])

        # Get initial and boundary conditions
        bcu, bcp = self.fetch_bcs(problem, u0, p0, t)

        # Remove boundary stress term if problem is periodic
        if is_periodic(bcp):
            beta = Constant(0)
        else:
            beta = Constant(1)

        # Problem parameters etc
        nu = Constant(problem.params.mu/problem.params.rho, name="nu")
        k  = Constant(dt, name="dt")
        f  = as_vector(problem.body_force(V))
        n  = FacetNormal(mesh)
        theta = self.params.theta

        # Forms
        a1 = (
            1.0/k*inner(u, v)*dx() +
            theta*2*inner(nu*epsilon(u), epsilon(v))*dx() -
            inner(p, div(v))*dx() -
            inner(q, div(u))*dx()
            )
        #a1 -= beta*theta*nu*inner(grad(u).T*n, v) * ds() # Unsure about the boundary terms
        a2 = theta*inner(grad(u)*u0, v)*dx()
        a = a1 + a2

        L = 1.0/k*inner(u0,v)*dx() -\
            (1-theta)*inner(grad(u0)*u0, v)*dx() -\
            (1-theta)*2*inner(nu*epsilon(u0), epsilon(v))*dx() +\
            dot(f,v)*dx()
        #L += beta*(1-theta)*nu*inner(grad(u).T*n, v) * ds() # Unsure about the boundary terms

        A, b = None, None
        if 0:
            A = Matrix()
            A1 = assemble(a1)
            A2 = assemble(a2)
            A.assign(A1+A2)

        # Time loop
        timer = Timer(self.params.enable_timer)
        for timestep in xrange(1,len(timesteps)):
            assign_time(t, timesteps[timestep])

            bcu, bcp = self.fetch_bcs(problem, u0, p0, t)
            timer.completed("update & fetch bc")

            b = assemble(L, tensor=b)
            for bc in bcu: bc.apply(b)
            for bc in bcp: bc.apply(b)
            timer.completed("assemble rhs & apply bc")

            # Fixed point loop
            count = 0
            err = 1e16
            while err > self.params.fixed_point_tolerance:
                count += 1
                if count > self.params.max_fixed_point_iterations:
                    raise Exception("Fixed point iteration did not converge.")

                if 0:
                    # Reassemble convection term
                    assemble(a2, tensor=A2, reset_sparsity=False)
                    A.assign(A1+A2)
                else:
                    A = assemble(a, tensor=A, reset_sparsity=A is None)

                for bc in bcu: bc.apply(A)
                for bc in bcp: bc.apply(A)
                timer.completed("assemble matrix & apply bc")

                # TODO: Iterative solver
                #solve(A, w1.vector(), b, "gmres", "ilu")
                solve(A, w1.vector(), b) # depends on w0
                timer.completed("solve")

                #err = norm(u1.vector()-u0.vector())/norm(u1.vector())
                #err = norm(u1-u0) / norm(u1)
                err = assemble((u1-u0)**2*dx()) / assemble(u1**2*dx())
                print "Fixed point iteration (%d, %g)" % (count, err)

                w0.assign(w1)

            print "Fixed point iteration converged in %d iterations. (err=%.4e)" %(count, err)
            update(u0, p0, t, timestep)
