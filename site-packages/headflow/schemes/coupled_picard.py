from __future__ import division

__author__ = "Kristian Valen-Sendstad <kvs@simula.no>"
__date__ = "2008-02-01"
__copyright__ = "Copyright (C) 2008-2010 " + __author__
__license__  = "GNU GPL version 3 or any later version"

# Modified by Anders Logg, 2008-2010.
# Modified by Martin Alnaes, 2013. (added penalty bcs)

from ..core.nsoptscheme import *
from ..core.utils import Timer, epsilon, sigma
from ..core.timesteps import compute_regular_timesteps




def family(degree):
    return "CG" if degree else "DG"

class Spaces:
    def __init__(self, mesh, u_degree, p_degree, mode):
        self.mode = mode

        # Dimensions
        d = mesh.ufl_cell().geometric_dimension()
        dims = list(xrange(d))

        # Make velocity spaces, both are useful in all modes
        self.U = FunctionSpace(mesh, family(u_degree), u_degree)
        self.V = VectorFunctionSpace(mesh, family(u_degree), u_degree)

        # Make pressure space
        if p_degree == u_degree:
            self.Q = self.U
        else:
            self.Q = FunctionSpace(mesh, family(p_degree), p_degree)

        # Define relative subspaces to make DBCs:
        if mode == "mixed":
            # Mixed space is only needed in this mode
            self.W = self.V*self.Q

            self.Ubc = [self.W.sub(0).sub(d) for d in dims]
            self.Qbc = self.W.sub(1)

        elif mode == "split":
            self.Ubc = [self.V.sub(d) for d in dims]
            self.Qbc = self.Q

        elif mode == "segregated":
            self.Ubc = [self.U for d in dims]
            self.Qbc = self.Q

        else:
            error("Unknown mode %s" % mode)


def assign_ics_mixed(up0, spaces, ics):
    up = as_vector(list(ics[0]) + [ics[1]])
    up0.assign(project(up, spaces.W))

def assign_ics_split(u0, p0, spaces, ics):
    u = as_vector(list(ics[0]))
    p = ics[1]
    u0.assign(project(u, spaces.V))
    p0.assign(project(p, spaces.Q))

def assign_ics_segregated(u0, p0, spaces, ics):
    for d in xrange(len(u0))
        u0[d].assign(project(ics[0][d], spaces.U))
    p0.assign(project(ics[1], spaces.Q))




class CoupledPicard(NSOptScheme):
    "Incremental pressure-correction scheme with penalty terms for boundary conditions."

    def __init__(self, params=None):
        NSOptScheme.__init__(self, params, segregated=False)

    @classmethod
    def default_user_params(cls):
        p = ParamDict(
            u_degree = 2,
            p_degree = 1,
            )
        return p

    def solve(self, problem, update):
        # Spatial parameters
        mesh = problem.mesh
        dx = problem.dx
        ds = problem.ds
        n  = FacetNormal(mesh)

        # Time parameters
        dt, timesteps = compute_regular_timesteps(problem)
        t = Time(t0=timesteps[0])

        # Function spaces (P2-P1)
        assert self.params.u_degree == 2
        assert self.params.p_degree == 1
        spaces = Spaces(mesh, 2, 1, "mixed")
        W = spaces.W

        # Test and trial functions
        u, p = TrialFunctions(W)
        v, q = TestFunctions(W)

        # Solution functions
        up0 = Function(W, name="up0") # Previous timestep
        up1 = Function(W, name="up1") # Last iterate of fixed-point in current timestep
        u0, p0 = split(up0)
        u1, p1 = split(up1)

        # Get observation functions
        observations = problem.observations(spaces, t)

        # Get control functions
        controls = problem.controls(spaces)

        # Get initial conditions
        ics = problem.initial_conditions(spaces, controls)

        # Get boundary conditions
        bcs = problem.boundary_conditions(spaces, t, controls) # TODO: need u,p here, consolidate with Oyvinds resistance conditions

        # Apply initial conditions
        assign_ics_mixed(up0, spaces, ics)

        # Use initial condition as initial guess
        up1.assign(up0)

        # Make scheme-specific representation of bcs # TODO: move this to a helper function?
        dims = list(xrange(len(n)))
        bcu, bcp = bcs
        bcs = []
        for bc in bcu:
            for d in dims:
                bcs += [DirichletBC(spaces.Ubc[d], bc[0][d], bc[1])]
        Lbc = sum(dot(pbc*n, v)*ds(region) for (pbc, region) in bcp)

        # Problem parameters
        nu = Constant(problem.params.mu/problem.params.rho, name="nu")
        k  = Constant(dt, name="dt")
        f  = as_vector(problem.body_force(spaces.V))

        # Picard linearization of Navier-Stokes, F = a*u - L = 0
        # NB! Scaling by k affects the nonlinear solver convergence! TODO: Understand what's best.
        a = (
            dot((1.0/k)*u + (grad(u)*u1), v)*dx
            + nu*inner(grad(u), grad(v))*dx
            - p*div(v)*dx - q*div(u)*dx
            )
        L = dot((1.0/k)*u0 + f, v)*dx - Lbc
        F = action(a, up1) - L

        # Create solver
        picard_problem = NonlinearVariationalProblem(F, up1, bcs, J=a)
        solver = NonlinearVariationalSolver(picard_problem)

        # TODO: Call update() with initial conditions?
        #update(u0, p0, float(t), 0)

        # Profiling object
        timer = Timer(self.params.enable_timer)

        # Loop over fixed timesteps
        for timestep in xrange(1,len(timesteps)):
            assign_time(t, timesteps[timestep])

            # Update various functions
            problem.update_observations(spaces, t, observations)
            #problem.update_controls(spaces, t, controls)
            problem.update_boundary_conditions(spaces, t, bcs)

            # Solve for up1
            solver.solve()

            # Rotate functions for next timestep
            up0.assign(up1)

            # Update postprocessing
            update(u0, p0, float(t), timestep) # TODO: Pass controls and observations here?

        # Make sure annotation gets that the timeloop is over
        finalize_time(t)

        # Return some quantities from the local namespace
        # TODO: The design of this is a bit ad-hoc...
        states = (u0, p0)
        scope = {
            "spaces": spaces,
            "observations": observations,
            "controls": controls,
            "states": states,
            "t": t,
            }
        return scope
