from __future__ import division

__author__ = "Martin Alnaes <martinal@simula.no>"
__date__ = "2013-05-22"
__copyright__ = "Copyright (C) 2013 " + __author__
__license__  = "GNU GPL version 3 or any later version"

from ..core.nsoptscheme import *
from ..core.utils import Timer
from ..core.timesteps import compute_regular_timesteps


###########################################################################
# Begin code to move to shared utilities for new problem/scheme interface #
###########################################################################

def element_args(suggested_family, degree):
    if suggested_family == "CG":
        if degree:
            return ("CG", degree)
        else:
            return ("DG", degree)
    if suggested_family == "DG":
        return ("DG", degree)
    if suggested_family == "CR":
        return ("CR", 1)
    return (suggested_family, degree)

class Spaces:
    def __init__(self, mesh, u_degree, p_degree, mode, u_family="CG", p_family="CG"):
        self.mode = mode

        # Dimensions
        self.d = mesh.ufl_cell().geometric_dimension()
        self.dims = range(self.d)

        # Make velocity spaces, both are useful in all modes
        self.U = FunctionSpace(mesh, *element_args(u_family, u_degree))
        self.V = VectorFunctionSpace(mesh, *element_args(u_family, u_degree))

        # Always make linear spaces for projecting to visualization files
        if (u_family, u_degree) == ("CG", 1):
            self.U_CG1 = self.U
            self.V_CG1 = self.V
        else:
            self.U_CG1 = FunctionSpace(mesh, "CG", 1)
            self.V_CG1 = VectorFunctionSpace(mesh, "CG", 1)

        # Make pressure space
        if p_degree == u_degree:
            self.Q = self.U
        else:
            self.Q = FunctionSpace(mesh, *element_args(p_family, p_degree))

        # Define relative subspaces to make DBCs:
        if mode == "mixed":
            # Mixed space is only needed in this mode
            self.W = self.V*self.Q

            self.Ubc = [self.W.sub(0).sub(d) for d in self.dims]
            self.Qbc = self.W.sub(1)

        elif mode == "split":
            self.Ubc = [self.V.sub(d) for d in self.dims]
            self.Qbc = self.Q

        elif mode == "segregated":
            self.Ubc = [self.U for d in self.dims]
            self.Qbc = self.Q

        else:
            error("Unknown mode %s" % mode)


def assign_ics_mixed(up0, spaces, ics):
    up = as_vector(list(ics[0]) + [ics[1]])
    up0.assign(project(up, spaces.W))

def assign_ics_split(u0, p0, spaces, ics):
    u = as_vector(list(ics[0]))
    p = ics[1]
    u0.assign(project(u, spaces.V))
    p0.assign(project(p, spaces.Q))

def assign_ics_segregated(u0, p0, spaces, ics):
    for d in spaces.dims:
        u0[d].assign(project(ics[0][d], spaces.U))
    p0.assign(project(ics[1], spaces.Q))


def _domainargs(problem, D):
    "Helper function to pass domain args if necessary."
    if isinstance(D, int):
        return (problem.facet_domains, D)
    else:
        return (D,)

def make_mixed_bcs(problem, spaces, bcs, v):
    bcu_raw, bcp_raw = bcs
    bcu = [DirichletBC(spaces.Ubc[d], functions[d], *_domainargs(problem, region))
           for functions, region in bcu_raw
           for d in spaces.dims]
    ds = problem.ds
    n = FacetNormal(problem.mesh)
    Lbc = -sum(dot(function*n, v)*ds(region) for (function, region) in bcp_raw)
    return bcu, Lbc

def make_split_bcs(problem, spaces, bcs):
    bcu_raw, bcp_raw = bcs
    bcu = [DirichletBC(spaces.Ubc[d], functions[d], *_domainargs(problem, region))
           for functions, region in bcu_raw
           for d in spaces.dims]
    bcp = [DirichletBC(spaces.Q, function, *_domainargs(problem, region)) for function, region in bcp_raw]
    return bcu, bcp

def make_segregated_bcs(problem, spaces, bcs):
    bcu_raw, bcp_raw = bcs
    bcu = [[DirichletBC(spaces.Ubc[d], functions[d], *_domainargs(problem, region))
            for d in spaces.dims]
           for functions, region in bcu_raw]
    bcp = [DirichletBC(spaces.Q, function, *_domainargs(problem, region)) for function, region in bcp_raw]
    return bcu, bcp


#########################################################################
# End code to move to shared utilities for new problem/scheme interface #
#########################################################################



class CoupledPicard(NSOptScheme):
    "Incremental pressure-correction scheme with penalty terms for boundary conditions."

    def __init__(self, params=None):
        NSOptScheme.__init__(self, params, segregated=False)

    @classmethod
    def default_user_params(cls):
        fc = ParamDict(
            optimize=True,
            cpp_optimize=True,
            cpp_optimize_flags="-O3 -march=native -fno-math-errno",
            quadrature_degree="auto",
            )
        p = ParamDict(
            # Default to P2-P1 (Taylor-Hood)
            u_family = "CG",
            u_degree = 2,
            p_degree = 1,

            picard_tolerance=1e-13,
            picard_max_iterations=20,
            picard_error_on_nonconvergence=False,

            reuse_lu_data=True,
            verbose=False,
            form_compiler_parameters=fc,
            )
        return p

    def solve(self, problem, update):
        # Spatial parameters
        mesh = problem.mesh
        dx = problem.dx
        ds = problem.ds
        n  = FacetNormal(mesh)

        # Time parameters
        dt, timesteps = compute_regular_timesteps(problem)
        t = Time(t0=timesteps[0])

        # Function spaces
        spaces = Spaces(mesh, self.params.u_degree, self.params.p_degree,
                        "mixed", u_family=self.params.u_family)
        W = spaces.W

        # Test and trial functions
        u, p = TrialFunctions(W)
        v, q = TestFunctions(W)

        # Solution functions
        up0 = Function(W, name="up0") # Previous timestep
        up1 = Function(W, name="up1") # Last iterate of fixed-point in current timestep
        u0, p0 = split(up0)
        u1, p1 = split(up1)

        # Get problem specific functions
        observations = problem.observations(spaces, t)
        controls = problem.controls(spaces)
        ics = problem.initial_conditions(spaces, controls)
        bcs = problem.boundary_conditions(spaces, u0, p0, t, controls) # TODO: should u0, p0 be last timestep?

        # Apply initial conditions and use it as initial guess
        assign_ics_mixed(up0, spaces, ics)
        up1.assign(up0)

        # Make scheme-specific representation of bcs
        bcu, Lbc = make_mixed_bcs(problem, spaces, bcs, v)

        # Problem parameters
        nu = Constant(problem.params.mu/problem.params.rho, name="nu")
        k  = Constant(dt, name="dt")
        f  = as_vector(problem.body_force(spaces.V))

        # Picard linearization of Navier-Stokes, F = a*u - L = 0
        eqchoice = 1
        if eqchoice == 1:
            # Not scaled by k
            a = (
                dot((1.0/k)*u + (grad(u)*u1), v)*dx()
                + nu*inner(grad(u), grad(v))*dx()
                - p*div(v)*dx() - q*div(u)*dx()
                )
            L = dot((1.0/k)*u0 + f, v)*dx() + Lbc
        if eqchoice == 2:
            # Scaled by k (smaller residual, nonlinear solver hits absolute stopping criteria faster)
            a = (
                dot(u + k*(grad(u)*u1), v)*dx()
                + (k*nu)*inner(grad(u), grad(v))*dx()
                - (k*p)*div(v)*dx() - (k*div(u))*q*dx()
                )
            L = dot(u0 + k*f, v)*dx() + k*Lbc
        if eqchoice == 3:
            # Stokes
            a = (
                + nu*inner(grad(u), grad(v))*dx()
                - p*div(v)*dx() - q*div(u)*dx()
                )
            L = Lbc
        # Build residual form from a, L
        F = action(a, up1) - L

        # Create solver
        picard_problem = NonlinearVariationalProblem(F, up1, bcu, J=a,
                                                     form_compiler_parameters=self.params.form_compiler_parameters)
        solver = NonlinearVariationalSolver(picard_problem)

        # Turn on the noise
        if self.params.verbose:
            solver.parameters["lu_solver"]["report"] = True
            solver.parameters["lu_solver"]["verbose"] = True
            solver.parameters["newton_solver"]["report"] = True

        # Speed up solvers with reuse
        if self.params.reuse_lu_data:
            solver.parameters["lu_solver"]["reuse_factorization"] = True
            solver.parameters["lu_solver"]["same_nonzero_pattern"] = True
            solver.parameters["reset_jacobian"] = False

        # Define stricter stopping criteria for "newton" (actually fixed point) solver
        solver.parameters["newton_solver"]["absolute_tolerance"] = self.params.picard_tolerance
        solver.parameters["newton_solver"]["relative_tolerance"] = self.params.picard_tolerance
        solver.parameters["newton_solver"]["maximum_iterations"] = self.params.picard_max_iterations
        solver.parameters["newton_solver"]["error_on_nonconvergence"] = self.params.picard_error_on_nonconvergence

        # TODO: Call update() with initial conditions in all schemes?
        update(u0, p0, float(t), 0)

        # Profiling object
        timer = Timer(self.params.enable_timer)

        # Loop over fixed timesteps
        for timestep in xrange(1,len(timesteps)):
            assign_time(t, timesteps[timestep])

            # Update various functions
            problem.update_observations(spaces, t, observations)
            #problem.update_controls(spaces, t, controls)
            problem.update_boundary_conditions(spaces, u0, p0, t, bcs)

            # Solve for up1
            solver.solve()

            # Rotate functions for next timestep
            up0.assign(up1)

            # Update postprocessing
            update(u0, p0, float(t), timestep) # TODO: Pass controls and observations here?

        # Make sure annotation gets that the timeloop is over
        finalize_time(t)

        # Return some quantities from the local namespace
        # TODO: The design of this is a bit ad-hoc...
        states = (u0, p0)
        scope = {
            "spaces": spaces,
            "observations": observations,
            "controls": controls,
            "states": states,
            "t": t,
            "timesteps": timesteps,
            }
        return scope
