from __future__ import division

__author__ = "Kristian Valen-Sendstad <kvs@simula.no>"
__date__ = "2008-02-01"
__copyright__ = "Copyright (C) 2008-2010 " + __author__
__license__  = "GNU GPL version 3 or any later version"

# Modified by Anders Logg, 2008-2010.
# Modified by Martin Alnaes, 2013. (added penalty bcs)

from ..core.nsscheme import *
from ..core.utils import Timer, epsilon, sigma
from ..core.timesteps import compute_regular_timesteps

def as_scalar_spaces(V):
    d = V.cell().d
    if V.num_sub_spaces() == 0:
        return [V]*d
    else:
        return [V.sub(i) for i in xrange(d)]

class PenaltyIPCS(NSScheme):
    "Incremental pressure-correction scheme with penalty terms for boundary conditions."

    def __init__(self, params=None):
        NSScheme.__init__(self, params, segregated=False)

    @classmethod
    def default_user_params(cls):
        params = ParamDict(
            use_penalty_pressure_bcs=True,
            penalty_gamma=50.0,
            )
        return params

    def build_pressure_penalty_bc_forms(self, problem, Q, bcp_raw):

        # Define trial and test functions (get (mesh,p,q) as input instead of Q?)
        p = TrialFunction(Q)
        q = TestFunction(Q)
        ds = problem.ds

        # Define Nitche discretization constants
        gamma = Constant(self.params.penalty_gamma)
        hE = Q.mesh().ufl_cell().max_facet_edge_length

        # The Nietche terms to integrate
        a_dirichlet = (gamma/hE)*(p*q) - Dn(p)*q - p*Dn(q)
        L_dirichlet = (gamma/hE)*q - Dn(q)

        # Collect Nietche terms for each subboundary
        a = []
        L = []
        for (pbc, D) in bcp_raw:
            a += [     a_dirichlet*ds(D) ]
            L += [ pbc*L_dirichlet*ds(D) ]
        return sum(a), sum(L)

    def build_bcs(self, problem, V, Q, t, controls):
        """Get dirichlet boundary conditions.

        Translates boundary conditions returned by problem
        into the right format for this scheme.

        Returns (bcu, bcp, a, L) where
        - bcu, bcp are lists of DirichletBC instances
        - a, L are forms to add to the pressure equation
        """
        bcu_raw, bcp_raw = problem.boundary_conditions(V, Q, t, controls)

        # Define velocity BCs depending on segregation choice in scheme
        Vsub = as_scalar_spaces(V)
        bcu = []
        for fs, D in bcu_raw:
            bclist = [DirichletBC(Vsub[i], f, D) for i,f in enumerate(fs)]
            if self._segregated:
                bcu.append(bclist)
            else:
                bcu.extend(bclist) # TODO: I think we can get rid of this by iterating over components in non-segregated schemes

        # Define pressure BCs depending on penalty method choice in scheme
        if self.params.use_penalty_pressure_bcs:
            a, L = self.build_pressure_penalty_bc_forms(problem, Q, bcp_raw)
            bcp = []
        else:
            a, L = 0, 0
            bcp = [DirichletBC(Q, f, D) for (f, D) in bcp_raw]

        return bcu, bcp, a, L

    def solve(self, problem, update):
        # Get spatial parameters
        mesh = problem.mesh
        dx = problem.dx
        ds = problem.ds

        # Get time parameters
        dt, timesteps = compute_regular_timesteps(problem)
        t = Constant(0.0)
        t.assign(timesteps[0])

        # Define function spaces
        V = VectorFunctionSpace(mesh, "CG", self.params.u_degree)
        Q = FunctionSpace(mesh, "CG", self.params.p_degree)
        Vsub = V.sub(0).collapse()

        # Test and trial functions
        v = TestFunction(V)
        q = TestFunction(Q)
        u = TrialFunction(V)
        p = TrialFunction(Q)

        # Functions
        #u0 = Function(V)
        #p0 = Function(Q)
        u1 = Function(V)
        p1 = Function(Q)

        # Get control functions
        controls = problem.controls(V, Q)

        # Get initial conditions
        uinit, pinit = problem.initial_conditions(Vsub, Q, controls)

        # Apply initial conditions
        u0 = project(as_vector(uinit), V)
        p0 = project(pinit, Q)
        #assign(u0, uinit)
        #assign(p0, pinit)

        # Get boundary conditions
        bcu, bcp, a_p_corr_bc, L_p_corr_bc = self.build_bcs(problem, V, Q, t, controls)
        assert not (bcp and a_p_corr_bc), "Got both penalty and DBC versions of pressure BCs."

        # Problem parameters
        nu = Constant(problem.params.mu/problem.params.rho)
        k  = Constant(dt)
        f  = as_vector(problem.body_force(V))
        n  = FacetNormal(mesh)

        # Tentative velocity step forms
        u_mean = 0.5 * (u + u0)
        u_diff = (u - u0)
        F_u_tent = ((1/k) * inner(v, u_diff) * dx()
                    + inner(v, grad(u0)*u0) * dx()
                    + inner(epsilon(v), sigma(u_mean, p0, nu)) * dx()
                    - nu * inner(grad(u_mean).T*n, v) * ds()
                    + inner(v, p0*n) * ds()
                    - inner(v, f) * dx())
        a_u_tent = lhs(F_u_tent)
        L_u_tent = rhs(F_u_tent)

        # Pressure correction forms
        a_p_corr = inner(grad(q), grad(p))*dx() + a_p_corr_bc
        L_p_corr = inner(grad(q), grad(p0))*dx() - (1/k)*q*div(u1)*dx() + L_p_corr_bc

        # Velocity correction forms
        a_u_corr = inner(v, u)*dx()
        L_u_corr = inner(v, u1)*dx() - k*inner(v, grad(p1-p0))*dx()

        # Assemble matrices
        A_u_tent = assemble(a_u_tent)
        A_p_corr = assemble(a_p_corr)
        A_u_corr = assemble(a_u_corr)

        if self.params.solver_p:
            solver_p_params = self.params.solver_p
        elif len(bcp) == 0:
            solver_p_params = self.params.solver_p_neumann
        else:
            solver_p_params = self.params.solver_p_dirichlet

        # Time loop
        timer = Timer(self.params.enable_timer)
        for timestep in xrange(1,len(timesteps)):
            t.assign(timesteps[timestep])

            # Update boundary condition functions
            problem.update_boundary_conditions(V, Q, t)
            timer.completed("update bcs")

            # Compute tentative velocity step
            b = assemble(L_u_tent)
            for bc in bcu: bc.apply(A_u_tent, b)
            timer.completed("u1 construct rhs")
            print "u1 rhs norm:", norm(b)

            iter = solve(A_u_tent, u1.vector(), b, *self.params.solver_u_tent)
            timer.completed("u1 solve (%s, %d, %d)"%(', '.join(self.params.solver_u_tent), b.size(), iter))
            print "u1 norm:", norm(u1.vector())

            # Pressure correction
            b = assemble(L_p_corr)
            for bc in bcp: bc.apply(A_p_corr, b)
            timer.completed("p construct rhs")
            print "pressure rhs norm:", norm(b)

            iter = solve(A_p_corr, p1.vector(), b, *solver_p_params)
            timer.completed("p solve (%s, %d, %d)"%(', '.join(solver_p_params), b.size(), iter))
            print "pressure norm:", norm(p1.vector())

            # Velocity correction
            b = assemble(L_u_corr)
            for bc in bcu: bc.apply(A_u_corr, b)
            timer.completed("u2 construct rhs")
            print "u2 rhs norm:", norm(b)

            solver_params = self.params.solver_u_corr
            iter = solve(A_u_corr, u1.vector(), b, *solver_params)
            timer.completed("u2 solve (%s, %d, %d)"%(', '.join(solver_params), b.size(),iter))
            print "u2 norm:", norm(u1.vector())

            # Update postprocessing
            update(u1, p1, float(t), timestep)

            # Rotate functions for next timestep
            u0.assign(u1)
            p0.assign(p1)

        scope = {
            "V": V,
            "Q": Q,
            "controls": controls,
            "state": (u0, p0),
            "t": t,
            }
        return scope
