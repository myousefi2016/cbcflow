from __future__ import division

__author__ = "Oyvind Evju <oyvinev@simula.no>"
__date__ = "2013-04-30"
__copyright__ = "Copyright (C) 2013 " + __author__
__license__  = "GNU GPL version 3 or any later version"

from ..core.nsscheme import *
from ..core.rhsgenerator import *
from ..core.utils import Timer, epsilon, sigma, is_periodic
from ..core.timesteps import compute_regular_timesteps
from ..core.schemeutils import assign_ics_split, make_velocity_bcs, make_pressure_bcs, make_mixed_bcs
from ..core.spaces import NSSpacePoolSplit

from time import time



class ExactSplitting(NSScheme):
    "Coupled scheme with block preconditioning using cbc.block"

    def __init__(self, params=None):
        NSScheme.__init__(self, params)

    @classmethod
    def default_params(cls):
        params = NSScheme.default_params()
        params.update(
            # Default to P2-P1 (Taylor-Hood)
            u_degree = 2,
            p_degree = 1,

            theta=0.5, # 0.5: Crank-Nicholson, 1.0: Backward Euler, 0.0: Forward Euler

            schur_tolerance=1e-6,
            )
        return params
    def solve(self, problem, update):
        #from block import *
        #from block.iterative import *
        #from block.algebraic.trilinos import *
        from block import block_assemble
        from block.iterative import LGMRES
        #from block.algebraic.trilinos import 
        #from block.algebraic.trilinos import IFPACK
        from block.algebraic.trilinos.IFPACK import DD_ILU, DD_Jacobi
        from block.algebraic.trilinos.Epetra import LumpedInvDiag
        from block.algebraic.trilinos.MLPrec import ML
        
        # Get problem parameters
        mesh = problem.mesh
        dx = problem.dx
        ds = problem.ds
        n  = FacetNormal(mesh)
        h = CellSize(mesh)

        # Timestepping
        dt, timesteps = compute_regular_timesteps(problem)
        t = Time(t0=timesteps[0])

        # Define function spaces
        spaces = NSSpacePoolSplit(mesh, self.params.u_degree, self.params.p_degree)
        V = spaces.V
        Q = spaces.Q

        # Test and trial functions
        v = TestFunction(V)
        q = TestFunction(Q)
        u = TrialFunction(V)
        p = TrialFunction(Q)
        
        # Functions
        u0 = Function(V, name="u0")
        u1 = Function(V, name="u1")
        u2 = Function(V, name="u2")
        u_corr = Function(V, name="u_corr")
        p0 = Function(Q, name="p0")
        p1 = Function(Q, name="p1")
        
        #v += 1e-2*h*h*dot(grad(v), u1)
        #v = v + Constant(0.1)*h*dot(grad(v), u1)
        


        # Get functions for data assimilation
        observations = problem.observations(spaces, t)
        controls = problem.controls(spaces)

        # Get initial conditions
        ics = problem.initial_conditions(spaces, controls)
        assign_ics_split(u0, p0, spaces, ics)
        u1.assign(u0)
        u2.assign(u1)
        p1.assign(p0)

        # Make scheme-specific representation of bcs
        bcs = problem.boundary_conditions(spaces, u0, p0, t, controls)
        bcu = make_velocity_bcs(problem, spaces, bcs)
        bcp = make_pressure_bcs(problem, spaces, bcs)
        bcu, Lbc = make_mixed_bcs(problem, spaces, bcs, v)
        
        # Problem coefficients
        nu = Constant(problem.params.mu/problem.params.rho)
        k  = Constant(dt)
        f  = as_vector(problem.body_force(spaces, t))
        theta = self.params.theta

        #delta = 1
        #vv = v+delta*h*h*dot(grad(v), u1)
        # Forms
        mu = inner(u,v)*dx()       
        mp = p*q*dx()
        au = inner(grad(u), grad(v))*dx()
        ap = inner(grad(p), grad(q))*dx()
               
        u_conv = 0.5*(3*u1-u0)
        #u_conv = u1
        cu = inner(grad(u)*u_conv, v)*dx()
        
        cp = inner(grad(p),u1)*q*dx()
        cp0 = inner(grad(p0), u1)*dx()
               
        
        b1 = -inner(p, div(v))*dx()
        #b1 = inner(grad(v), p*Identity(u.cell().d))*dx()
        b10 = -inner(p0, div(v))*dx()
        
        b2 = -inner(q, div(u))*dx()
        b20 = -inner(q, div(u1))*dx()
        
        '''
        if True: # Cebral implementation of SUPG parameter
            dl = ((12/sqrt(2))*(tetrahedron.volume))**.33333333
            gamma = dl**2
            #gamma =   (1/k)*(dl**2/(2*sqrt(inner(u1,u1))*dl+4*nu))
            #supgII = (1/k)*(dl**2/(2*sqrt(inner(u2,u2))*dl+4*nu))
            print 'Using supg with dl**2/(2*sqrt(inner(u,u))*dl+4*nu)/k'
        else:
            supg = Constant(1)
            #supgII = Constant(1)
            print 'Using supg with Constant(1)'
        '''
        
        fu = 1/k*mu+theta*nu*au+theta*cu
        #supg = gamma*k*inner(grad(v)*u1, grad(u1)*u1)*dx()
        
        epsilon = Constant(1e-1)
        gamma = epsilon*dt*h**2
        supg = gamma*inner(grad(v)*u_conv, grad(u)*u_conv)*dx()
        
        #print dir(fu)
        #fu.compute_form_data()
        #print fu.form_data()
        #supg.compute_form_data()
        #print supg.form_data()
        
        #print fu.rank()
        #print supg.rank()
        #exit()
        
        #SUPG = assemble(supg*k*inner(grad(v)*u1, grad(u1)*(u1))*dx())
        #fu += supg*k*inner(grad(v)*u1, grad(u1)*(u1))*dx
        #fu = ( 1/k*inner(u, vv)*dx()
        #      + theta*inner(grad(u), grad(vv))*dx()
        #      + theta*inner(grad(u))
        fp = 1/k*mp+theta*nu*ap+theta*cp
        
        Mu = assemble(mu, bcs=bcu)
        Cu = assemble(cu, bcs=bcu)
        Ku = assemble(au, bcs=bcu)
        SUPG = assemble(supg, bcs=bcu)
        
        #Mu_inv = ConjGrad(Mu, DD_ILU(Mu), tolerance=1e-5, initial_guess=None, iter=None, maxiter=200, name=None, show=1, rprecond=None, retain_guess=True)
        Mu_inv = LumpedInvDiag(Mu)
        #print Mu_inv
        
        '''
        I = Matrix()
        _mesh = UnitIntervalMesh(V.dim())
        _V = FunctionSpace(_mesh, 'DG', 0)
        _f = TrialFunction(_V)
        _g = TestFunction(_V)
        from dolfin import dx as _dx
        I = assemble( _f * _g * _dx )
        I *= V.dim()
        print I
        '''
        
        #from numpy import array
        #arr = array(range(V.dim()), dtype="intc")
        #print arr
        #print arr.dtype
        #exit()
        #I.ident_zeros()
        #exit()
        
        
        #Mu_inv = I * Mu_inv
        #print Identity(V.dim())
        #print type(Identity(V.dim()))
        #print Mu_inv
        #print dir(Mu_inv)
        #exit()
        
        #H = dt*Mu_inv # First order (Chorin)
        #H = dt*(Identity(u.cell().d) - dt*Mu_inv*(Ku+Cu))*Mu_inv # 2nd order, not always definite positive
        #H = dt*Mu_inv - dt**2*Mu_inv*Mu_inv*Ku - dt**2*Mu_inv*Mu_inv*Cu
        #H = k*(Identity(u.cell().d) - k*Mu_inv*(Ku+Cu) + k**2*(Mu_inv*(Ku+Cu))**2)*Mu_inv # 3rd order, always definite positive
        #H = dt*Mu_inv - dt**2*Mu_inv*(Ku+Cu) + dt**3*Mu_inv*(Mu_inv*(Ku+Cu))

        #if theta == 0.5:
        #    H = dt*Mu_inv - dt**2*Mu_inv*Mu_inv*Ku - dt**2*Mu_inv*Mu_inv*Cu # Use second order approximation (not always positive definite)
        #else:
        #    H = dt*Mu_inv
        H = dt*Mu_inv

        # Preconditioner   
        Ap = assemble(ap)
        Fp = assemble(fp)
        Mp = assemble(mp)
        
        
        for bc in bcp:
            bc.apply(Ap)
            bc.apply(Fp)
            bc.apply(Mp)

        #AA = block_assemble([[fu, b1],[theta*b2, 0]], bcs=[bcu, []])
        AA = block_assemble([[fu + supg, b1],[theta*b2, 0]], bcs=[bcu, []])

        A = AA[0,0]
        D = AA[1,0]
        G = AA[0,1]
               
        #A_inv = DD_ILU(A)
        #A_inv = InvDiag(A)
        A_inv = H
        #A_inv = DD_Amesos(A)
        #if self.params.u_degree == 2:
        #    epsilon = 0
        #else:
        #    epsilon = 1e-2
        S = D*A_inv*G# + dt*epsilon*Mp
        Fp_inv = DD_ILU(Fp)
        Mp_inv = DD_Jacobi(Mp)
        Ap_inv = ML(Ap)
        #X = Ap*Fp_inv*Mp
        #X_inv = Mp_inv*Fp*Ap_inv
        #X_inv = 1.0/dt*Ap_inv# + dt*epsilon*Mp_inv
        X_inv = 1.0/dt*Ap_inv
        #X_inv = D*Mu*G
        
        #print D
        #print G
        #print dir(D)
        #print type(D)
        #exit()
        #D = D.down_cast()
        #G = G.down_cast()
        #assemble(D*G)
        
        #X = D*G
        #X = D.__imul__(G)
        #help
        #print X
        #print dir(X)
        #exit()
        #X = X.block_collapse()
        #print X
        #print type(X)
        #print dir(X)
        #exit()
        
        
        
        #X_inv = DD_ILU(dt*D*G)
        #exit()
        
        L0 = ( (1/k)*dot(u1,v)*dx() 
              #- (1-theta)*(cu1 + nu*au1 - b10)
              - (1-theta)*dot(grad(u1)*u_conv, v)*dx()
              - (1-theta)*nu*inner(grad(u1), grad(v))*dx()
              #+ b10
              + Lbc
              + dot(f,v)*dx() )
        #L1 = Constant((1-theta))*q*div(u1)*dx()
        L1 = Constant(0)*q*div(u1)*dx()
        #L1 = Constant(1-theta)*b20
        
        #bb0_petsc = PETScVector()
        #assemble(L0, tensor=bb0_petsc)
        bb0 = assemble(L0, bcs=bcu)
        bb1 = assemble(L1)

        # Call update() with initial conditions
        update(u1, p0, float(t), 0, spaces)

        guess = None
        # Loop over fixed timesteps
        for timestep in xrange(1,len(timesteps)):
            assign_time(t, timesteps[timestep])
        
            t0 = time()
            # Update various functions
            problem.update(spaces, u1, p0, t, timestep, bcs, observations, controls)

            t1 = time()
            print "Time spent updating: ", t1-t0
                
            #print norm(u1)
            #AA = block_assemble([[fu, b1],[theta*b2, 0]], bcs=[bcu, []])

            #A = AA[0,0]
            #D = AA[1,0]
            #G = AA[0,1]
            
            
            # Update terms dependent on previous solution (convection terms)
            A.axpy(-1.0*theta, Cu, True)
            A.axpy(-1.0, SUPG, True)
            #Fu.axpy(-1.0*theta, Cu, True)
            assemble(supg, bcs=bcu, tensor=SUPG)
            assemble(cu, bcs=bcu, tensor=Cu)
            A.axpy(1.0*theta, Cu, True)
            A.axpy(1.0, SUPG, True)
            
            
            #Fu.axpy(1.0*theta, Cu, True)
            
            #Fp.axpy(-1.0, Cp, True)
            #assemble(cp, tensor=Cp)
            #Fp.axpy(1.0, Cp, True)
            
            assemble(L0, bcs=bcu, tensor=bb0)
            assemble(L1, tensor=bb1)
            
            t2 = time()
            print "Time spent re-assembling: ", t2-t1
            #solve(A, u1.vector(), bb0)
            #A_inv = LGMRES(A, precond=DD_ILU(A), tolerance=1e-6)
            #u1.vector()[:] = A_inv * bb0
            #plot(u1, interactive=True)
            Aprec = DD_ILU(A)
            A_inv1 = LGMRES(A, precond=Aprec, initial_guess=u1.vector(), maxiter=250, nonconvergence_is_fatal=True)
            #solve(A, u1.vector(), bb0, "gmres", "ilu")
            u1.vector()[:] = A_inv1*bb0
            #solve(Fu, u1.vector(), bb0, "gmres", "ml_amg")
            #try:
            #    solve(A, u1.vector(), bb0, "gmres", "ml_amg")
            #except:
            #    print MPI.process_number()
            #    solve(A, u1.vector(), bb0, "gmres", "ilu")
            S_inv = LGMRES(S, precond=X_inv, tolerance=self.params.schur_tolerance, maxiter=50, show=1, nonconvergence_is_fatal=True)
            p1.vector()[:] = -S_inv * (bb1 - D * u1.vector())
            #solve(A, u2.vector(), A*u1.vector()-G*p1.vector(), "gmres", "ml_amg")
            #solve(A, u_corr.vector(), -G*p1.vector(), "gmres", "ilu")
            #u2.vector()[:] = u1.vector() + u_corr.vector()
            
            #A.axpy(-1.0, SUPG, True)
            #assemble(supg, bcs=bcu, tensor=SUPG)
            #A.axpy(1.0, SUPG, True)
            
            A_inv2 = LGMRES(A, precond=Aprec, initial_guess=u_corr.vector(), maxiter=250, nonconvergence_is_fatal=True)
            
            
            u_corr.vector()[:] = -A_inv2*G*p1.vector()           
            u2.vector()[:] = u1.vector() + u_corr.vector()
            #u2.vector()[:] = -A_inv*G*p1.vector() + u1.vector()
            #p1.vector()[:] = -S_inv * (bb1 - D * u1vector)
            #u2.vector()[:] = -A_inv*G*p1.vector() + u1.vector()
            '''
            Q1 = assemble(dot(u2, n)*ds(1))
            A1 = assemble(Constant(1)*ds(1), mesh=mesh)
            Q2 = assemble(dot(u2, n)*ds(2))
            Q3 = assemble(dot(u2, n)*ds(3))
            
            Diam = 2*sqrt(A1/pi)
            Re = Q1*Diam/(float(nu)*A1)
            
            if MPI.process_number() == 0:
                print "Reynolds number: ", Re
                print Q1
                print Q2
                print Q3
            MPI.barrier()
            '''
            # Update last timestep
            u0.assign(u1)
            u1.assign(u2)
            p0.assign(p1)
        
            #print "Fixed point iteration converged in %d iterations. (err=%.4e)" %(count, err)
            update(u1, p0, float(t), timestep, spaces)

        # Make sure annotation gets that the timeloop is over
        finalize_time(t)

        # Return some quantities from the local namespace
        states = (u1, p0)
        namespace = {
            "spaces": spaces,
            "observations": observations,
            "controls": controls,
            "states": states,
            "t": t,
            "timesteps": timesteps,
            }
        return namespace
