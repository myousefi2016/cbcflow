from __future__ import division

__author__ = "Oyvind Evju <oyvinev@simula.no>"
__date__ = "2013-04-30"
__copyright__ = "Copyright (C) 2013 " + __author__
__license__  = "GNU GPL version 3 or any later version"

from ..core.nsscheme import *
from ..core.rhsgenerator import *
from ..core.utils import Timer, epsilon, sigma, is_periodic
from ..core.timesteps import compute_regular_timesteps
from ..core.schemeutils import assign_ics_split, make_velocity_bcs, make_pressure_bcs, make_mixed_bcs
from ..core.spaces import NSSpacePoolSplit

from time import time

class ExactSplitting(NSScheme):
    "Coupled scheme with block preconditioning using cbc.block"

    def __init__(self, params=None):
        NSScheme.__init__(self, params)

    @classmethod
    def default_params(cls):
        params = NSScheme.default_params()
        params.update(
            # Default to P2-P1 (Taylor-Hood)
            u_degree = 2,
            p_degree = 1,

            theta=0.5, # 0.5: Crank-Nicholson, 1.0: Backward Euler, 0.0: Forward Euler

            schur_tolerance=1e-12,
            conv_diff_tolerance=1e-12,
            supg = 1e-1,
            )
        return params

    def solve(self, problem, update):
        from block import block_assemble
        from block.iterative import LGMRES
        from block.algebraic.trilinos.IFPACK import DD_ILU, DD_Jacobi, DD_Amesos
        from block.algebraic.trilinos.Epetra import LumpedInvDiag
        from block.algebraic.trilinos.MLPrec import ML
        
        # Get problem parameters
        mesh = problem.mesh
        dx = problem.dx
        ds = problem.ds
        n  = FacetNormal(mesh)
        h = CellSize(mesh)

        # Timestepping
        dt, timesteps = compute_regular_timesteps(problem)
        t = Time(t0=timesteps[0])

        # Define function spaces
        spaces = NSSpacePoolSplit(mesh, self.params.u_degree, self.params.p_degree)
        V = spaces.V
        Q = spaces.Q

        # Test and trial functions
        v = TestFunction(V)
        q = TestFunction(Q)
        u = TrialFunction(V)
        p = TrialFunction(Q)
        
        # Functions
        u0 = Function(V, name="u0")
        u1 = Function(V, name="u1")
        u2 = Function(V, name="u2")
        u_corr = Function(V, name="u_corr")
        p0 = Function(Q, name="p0")
        p1 = Function(Q, name="p1")
        
        # Get functions for data assimilation
        observations = problem.observations(spaces, t)
        controls = problem.controls(spaces)

        # Get initial conditions
        ics = problem.initial_conditions(spaces, controls)
        assign_ics_split(u0, p0, spaces, ics)
        u1.assign(u0)
        u2.assign(u1)
        p1.assign(p0)

        # Make scheme-specific representation of bcs
        bcs = problem.boundary_conditions(spaces, u0, p0, t, controls)
        bcu = make_velocity_bcs(problem, spaces, bcs)
        bcp = make_pressure_bcs(problem, spaces, bcs)
        bcu, Lbc = make_mixed_bcs(problem, spaces, bcs, v)
        
        # Problem coefficients
        nu = Constant(problem.params.mu/problem.params.rho)
        k  = Constant(dt)
        f  = as_vector(problem.body_force(spaces, t))
        theta = self.params.theta

        # Forms
        mu = inner(u,v)*dx()       
        au = inner(grad(u), grad(v))*dx()
        #au = 2*inner(epsilon(u), epsilon(v))*dx() - inner(grad(u).T*n, v) * ds()
               
        #u_conv = 0.5*(3*u1-u0)
        u_conv = u1
        cu = inner(grad(u)*u_conv, v)*dx()
                             
        b1 = -inner(p, div(v))*dx()
        b2 = -inner(q, div(u))*dx()
        
        fu = 1/k*mu+theta*nu*au+theta*cu
        
        delta = Constant(self.params.supg)
        gamma = delta*dt*h**2
        supg = gamma*inner(grad(v)*u_conv, grad(u)*u_conv)*dx()
        
        Cu = assemble(cu, bcs=bcu)
        #Ku = assemble(au, bcs=bcu)
        
        if float(delta) > 0:
            SUPG = assemble(supg, bcs=bcu)

        #AA = block_assemble([[fu, b1],[theta*b2, 0]], bcs=[bcu, []])
        AA = block_assemble([[fu + supg, b1],[theta*b2, 0]], bcs=[bcu, []])

        A = AA[0,0]
        D = AA[1,0]
        G = AA[0,1]
        
        L0 = ( (1/k)*dot(u1,v)*dx() 
              - (1-theta)*dot(grad(u1)*u_conv, v)*dx()
              - (1-theta)*nu*inner(grad(u1), grad(v))*dx()
              #- (1-theta)*2*nu*inner(epsilon(u1), epsilon(v))*dx()
              #+ (1-theta)*nu*inner(grad(u1).T*n, v)*ds()
              + (1-theta)*p0*div(v)*dx()
              + Lbc
              + dot(f,v)*dx() )
        
        L1 = Constant(0)*q*div(u1)*dx()
        
        bb0 = assemble(L0, bcs=bcu)
        bb1 = assemble(L1)
        
        
        # Schur complement
        Mu = assemble(mu, bcs=bcu)
        Mu_inv = LumpedInvDiag(Mu)
        H = dt*Mu_inv # First order (Chorin)
        #H = dt*Mu_inv - dt**2*Mu_inv*Mu_inv*Ku - dt**2*Mu_inv*Mu_inv*Cu # 2nd order, not always definite positive
        #H = dt*Mu_inv - dt**2*Mu_inv*(Ku+Cu) + dt**3*Mu_inv*(Mu_inv*(Ku+Cu))# 3rd order, always definite positive

        #A_inv = DD_ILU(A)
        #A_inv = InvDiag(A)
        A_inv = H
        #A_inv = DD_Amesos(A)
        
        S = D*A_inv*G # Schur complement
        
        
        # Preconditioner   
        Ap = assemble(dot(grad(p), grad(q))*dx())      
        
        for bc in bcp:
            bc.apply(Ap)

        Ap_inv = ML(Ap)
        X_inv = 1.0/dt*Ap_inv
        
        

        # Call update() with initial conditions
        update(u1, p0, float(t), 0, spaces)

        guess = None
        # Loop over fixed timesteps
        for timestep in xrange(1,len(timesteps)):
            assign_time(t, timesteps[timestep])
        
            t0 = time()
            # Update various functions
            problem.update(spaces, u1, p0, t, timestep, bcs, observations, controls)

            t1 = time()
            print "Time spent updating: ", t1-t0
                
            
            # Update terms dependent on previous solution (convection terms)
            A.axpy(-1.0*theta, Cu, True)
            assemble(cu, bcs=bcu, tensor=Cu)
            A.axpy(1.0*theta, Cu, True)
            if float(delta) > 0:
                A.axpy(-1.0, SUPG, True)
                assemble(supg, bcs=bcu, tensor=SUPG)
                A.axpy(1.0, SUPG, True)
            
            assemble(L0, bcs=bcu, tensor=bb0)
            assemble(L1, tensor=bb1)
            
            t2 = time()
            print "Time spent re-assembling: ", t2-t1
            Aprec = DD_ILU(A)
            A_inv1 = LGMRES(A, precond=Aprec, initial_guess=u1.vector(), maxiter=250, nonconvergence_is_fatal=True, tolerance=self.params.conv_diff_tolerance)
            u1.vector()[:] = A_inv1*bb0

            S_inv = LGMRES(S, precond=X_inv, tolerance=self.params.schur_tolerance, maxiter=100, show=1, nonconvergence_is_fatal=True)
            p1.vector()[:] = -S_inv * (bb1 - D * u1.vector())

            A_inv2 = LGMRES(A, precond=Aprec, initial_guess=u_corr.vector(), maxiter=250, nonconvergence_is_fatal=True, tolerance=self.params.conv_diff_tolerance)
            u_corr.vector()[:] = -A_inv2*G*p1.vector()           
            u2.vector()[:] = u1.vector() + u_corr.vector()

            '''
            Q1 = assemble(dot(u2, n)*ds(1))
            A1 = assemble(Constant(1)*ds(1), mesh=mesh)
            Q2 = assemble(dot(u2, n)*ds(2))
            Q3 = assemble(dot(u2, n)*ds(3))
            
            Diam = 2*sqrt(A1/pi)
            Re = Q1*Diam/(float(nu)*A1)
            
            if MPI.process_number() == 0:
                print "Reynolds number: ", Re
                print Q1
                print Q2
                print Q3
            MPI.barrier()
            '''

            # Update last timestep
            u0.assign(u1)
            u1.assign(u2)
            p0.assign(p1)
        
            #print "Fixed point iteration converged in %d iterations. (err=%.4e)" %(count, err)
            update(u1, p0, float(t), timestep, spaces)

        # Make sure annotation gets that the timeloop is over
        finalize_time(t)

        # Return some quantities from the local namespace
        states = (u1, p0)
        namespace = {
            "spaces": spaces,
            "observations": observations,
            "controls": controls,
            "states": states,
            "t": t,
            "timesteps": timesteps,
            }
        return namespace
