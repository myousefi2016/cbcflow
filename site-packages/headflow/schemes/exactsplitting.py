from __future__ import division

__author__ = "Oyvind Evju <oyvinev@simula.no>"
__date__ = "2013-04-30"
__copyright__ = "Copyright (C) 2013 " + __author__
__license__  = "GNU GPL version 3 or any later version"

from ..core.nsscheme import *
from ..core.rhsgenerator import *
from ..core.utils import Timer, epsilon, sigma, is_periodic
from ..core.timesteps import compute_regular_timesteps
from ..core.schemeutils import assign_ics_split, make_velocity_bcs, make_pressure_bcs, make_mixed_bcs
from ..core.spaces import NSSpacePoolSplit

from time import time



class ExactSplitting(NSScheme):
    "Coupled scheme with block preconditioning using cbc.block"

    def __init__(self, params=None):
        NSScheme.__init__(self, params)

    @classmethod
    def default_params(cls):
        params = NSScheme.default_params()
        params.update(
            # Default to P2-P1 (Taylor-Hood)
            u_degree = 2,
            p_degree = 1,

            theta=0.5, # 0.5: Crank-Nicholson, 1.0: Backward Euler, 0.0: Forward Euler

            schur_tolerance=1e-6,
            )
        return params
    def solve(self, problem, update):
        from block import *
        from block.iterative import *
        from block.algebraic.trilinos import *
        
        # Get problem parameters
        mesh = problem.mesh
        dx = problem.dx
        ds = problem.ds
        n  = FacetNormal(mesh)

        # Timestepping
        dt, timesteps = compute_regular_timesteps(problem)
        t = Time(t0=timesteps[0])

        # Define function spaces
        spaces = NSSpacePoolSplit(mesh, self.params.u_degree, self.params.p_degree)
        V = spaces.V
        Q = spaces.Q

        # Test and trial functions
        v = TestFunction(V)
        q = TestFunction(Q)
        u = TrialFunction(V)
        p = TrialFunction(Q)

        # Functions
        u0 = Function(V, name="u0")
        u1 = Function(V, name="u1")
        u2 = Function(V, name="u2")
        p0 = Function(Q, name="p0")
        p1 = Function(Q, name="p1")

        # Get functions for data assimilation
        observations = problem.observations(spaces, t)
        controls = problem.controls(spaces)

        # Get initial conditions
        ics = problem.initial_conditions(spaces, controls)
        assign_ics_split(u0, p0, spaces, ics)
        u1.assign(u0)
        u2.assign(u1)
        p1.assign(p0)

        # Make scheme-specific representation of bcs
        bcs = problem.boundary_conditions(spaces, u0, p0, t, controls)
        bcu = make_velocity_bcs(problem, spaces, bcs)
        bcp = make_pressure_bcs(problem, spaces, bcs)
        bcu, Lbc = make_mixed_bcs(problem, spaces, bcs, v)
        
        # Problem coefficients
        nu = Constant(problem.params.mu/problem.params.rho)
        k  = Constant(dt)
        f  = as_vector(problem.body_force(spaces, t))
        theta = self.params.theta
        #theta = 1.0

        # Forms
        mu = inner(u,v)*dx()       
        mp = p*q*dx()
        au = inner(grad(u), grad(v))*dx()
        ap = inner(grad(p), grad(q))*dx()
               
        #u_conv = 0.5*(3*u1-u0)
        u_conv = u1
        cu = inner(grad(u)*u_conv, v)*dx()
        
        cp = inner(grad(p),u1)*q*dx()
        cp0 = inner(grad(p0), u1)*dx()
               
        
        b1 = -inner(p, div(v))*dx()
        #b1 = inner(grad(v), p*Identity(u.cell().d))*dx()
        b10 = -inner(p0, div(v))*dx()
        
        b2 = -inner(q, div(u))*dx()
        b20 = -inner(q, div(u1))*dx()
        
        fu = 1/k*mu+theta*nu*au+theta*cu
        fp = 1/k*mp+theta*nu*ap+theta*cp
        
        Cu = assemble(cu, bcs=bcu)

        # Preconditioner   
        Ap = assemble(ap)
        Fp = assemble(fp)
        Mp = assemble(mp)
        
        for bc in bcp:
            bc.apply(Ap)
            bc.apply(Fp)
            bc.apply(Mp)

        AA = block_assemble([[fu, b1],[theta*b2, 0]], bcs=[bcu, []])

        A = AA[0,0]
        D = AA[1,0]
        G = AA[0,1]
        
        A_inv = DD_ILU(A)
        #A_inv = InvDiag(A)
        #A_inv = DD_Amesos(A)
        
        S = D*A_inv*G
        Fp_inv = DD_ILU(Fp)
        Mp_inv = DD_Jacobi(Mp)
        Ap_inv = ML(Ap)
        X = Ap*Fp_inv*Mp
        X_inv = Mp_inv*Fp*Ap_inv
        
        L0 = ( (1/k)*dot(u1,v)*dx() 
              #- (1-theta)*(cu1 + nu*au1 - b10)
              - (1-theta)*dot(grad(u1)*u_conv, v)*dx()
              - (1-theta)*nu*inner(grad(u1), grad(v))*dx()
              + Lbc
              + dot(f,v)*dx() )
        L1 = Constant((1-theta))*q*div(u1)*dx()
        #L1 = Constant(0)*q*div(u1)*dx()
        #L1 = Constant(1-theta)*b20
        
        #bb0_petsc = PETScVector()
        #assemble(L0, tensor=bb0_petsc)
        bb0 = assemble(L0, bcs=bcu)
        bb1 = assemble(L1)

        # Call update() with initial conditions
        update(u1, p0, float(t), 0, spaces)

        guess = None
        # Loop over fixed timesteps
        for timestep in xrange(1,len(timesteps)):
            assign_time(t, timesteps[timestep])
        
            # Update various functions
            problem.update(spaces, u1, p0, t, timestep, bcs, observations, controls)

            t1 = time()
                
            #print norm(u1)
            
            # Update terms dependent on previous solution (convection terms)
            A.axpy(-1.0*theta, Cu, True)
            #Fu.axpy(-1.0*theta, Cu, True)
            assemble(cu, bcs=bcu, tensor=Cu)
            A.axpy(1.0*theta, Cu, True)
            #Fu.axpy(1.0*theta, Cu, True)
            
            #Fp.axpy(-1.0, Cp, True)
            #assemble(cp, tensor=Cp)
            #Fp.axpy(1.0, Cp, True)
            
            assemble(L0, bcs=bcu, tensor=bb0)
            assemble(L1, tensor=bb1)
            #solve(A, u1.vector(), bb0)
            solve(A, u1.vector(), bb0, "gmres", "ilu")
            S_inv = LGMRES(S, precond=X_inv, tolerance=self.params.schur_tolerance, maxiter=50, show=1)
            p1.vector()[:] = -S_inv * (bb1 - D * u1.vector())
            u2.vector()[:] = -A_inv*G*p1.vector() + u1.vector()
            #p1.vector()[:] = -S_inv * (bb1 - D * u1vector)
            #u2.vector()[:] = -A_inv*G*p1.vector() + u1vector
            
            # Update last timestep
            u0.assign(u1)
            u1.assign(u2)
            p0.assign(p1)
        
            #print "Fixed point iteration converged in %d iterations. (err=%.4e)" %(count, err)
            update(u1, p0, float(t), timestep, spaces)

        # Make sure annotation gets that the timeloop is over
        finalize_time(t)

        # Return some quantities from the local namespace
        states = (u1, p0)
        namespace = {
            "spaces": spaces,
            "observations": observations,
            "controls": controls,
            "states": states,
            "t": t,
            "timesteps": timesteps,
            }
        return namespace
