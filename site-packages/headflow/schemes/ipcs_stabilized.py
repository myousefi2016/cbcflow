from __future__ import division

__author__ = "Kristian Valen-Sendstad <kvs@simula.no>"
__date__ = "2008-02-01"
__copyright__ = "Copyright (C) 2008-2010 " + __author__
__license__  = "GNU GPL version 3 or any later version"

# Modified by Anders Logg, 2008-2010.

from ..core.nsscheme import *
from ..core.utils import Timer, epsilon, sigma, is_periodic
from ..core.timesteps import compute_regular_timesteps

class IPCS_Stabilized(NSScheme):
    "Incremental pressure-correction scheme."

    def __init__(self, params=None):
        NSScheme.__init__(self, params, segregated=False)

    def solve(self, problem, update):
        # Get problem parameters
        mesh = problem.mesh
        dt, timesteps = compute_regular_timesteps(problem)
        t = timesteps[0]
        dx = problem.dx
        ds = problem.ds

        # Define function spaces
        V = VectorFunctionSpace(mesh, "CG", self.params.u_degree)
        Q = FunctionSpace(mesh, "CG", self.params.p_degree)

        # Get initial conditions
        u0, p0 = problem.initial_conditions(V, Q)
        u0 = project(as_vector(u0), V)
        p0 = project(p0, Q)

        # Get boundary conditions
        bcu, bcp = self.fetch_bcs(problem, u0, p0, t)

        # Remove boundary stress term if problem is periodic
        beta = 0 if is_periodic(bcp) else 1

        #delta = CellSize(mesh)
        delta = Constant(1e-4)

        # Test and trial functions
        v = TestFunction(V)
        w = TestFunction(V) + delta*grad(TestFunction(V))*u0
        q = TestFunction(Q)
        u = TrialFunction(V)
        p = TrialFunction(Q)

        # Functions
        u1 = Function(V)
        p1 = Function(p0)

        nu = Constant(problem.params.mu/problem.params.rho)
        
        k  = Constant(dt)
        f  = as_vector(problem.body_force(V))
        n  = FacetNormal(mesh)


        
        # Tentative velocity step
        u_mean = 0.5 * (u + u0)
        u_diff = (u - u0)
        F_u_tent = ((1/k) * inner(w, u_diff) * dx()
                    + inner(w, grad(u0)*u0) * dx()
                    + inner(epsilon(w), sigma(u_mean, p0, nu)) * dx()
                    - beta * nu * inner(grad(u_mean).T*n, w) * ds()
                    + inner(w, p0*n) * ds()
                    - inner(w, f) * dx())

        a_u_tent = lhs(F_u_tent)
        L_u_tent = rhs(F_u_tent)

        # Pressure correction
        a_p_corr = inner(grad(q), grad(p))*dx()
        L_p_corr = inner(grad(q), grad(p0))*dx() - (1/k)*q*div(u1)*dx()

        # Velocity correction
        F_corr = inner(v, u)*dx() - inner(v, u1)*dx() + k*inner(v, grad(p1-p0))*dx()
        #F_corr = inner(w, u)*dx() - inner(w, u1)*dx() + k*inner(w, grad(p1-p0))*dx()
        
        #a_u_corr = inner(v, u)*dx()
        #L_u_corr = inner(v, u1)*dx() - k*inner(v, grad(p1-p0))*dx()

        a_u_corr = lhs(F_corr)
        L_u_corr = rhs(F_corr)

        # Assemble matrices
        A_u_tent = assemble(a_u_tent)
        A_p_corr = assemble(a_p_corr)
        A_u_corr = assemble(a_u_corr)

        if self.params.solver_p:
            solver_p_params = self.params.solver_p
        elif len(bcp) == 0 or is_periodic(bcp):
            solver_p_params = self.params.solver_p_neumann
        else:
            solver_p_params = self.params.solver_p_dirichlet

        # Time loop
        timer = Timer(self.params.enable_timer)
        for timestep in xrange(1,len(timesteps)):
            t = timesteps[timestep]

            # Get boundary conditions
            bcu, bcp = self.fetch_bcs(problem, u0, p0, t)
            timer.completed("update & fetch bc")

            # Compute tentative velocity step
            assemble(a_u_tent, tensor=A_u_tent)
            b = assemble(L_u_tent)
            for bc in bcu: bc.apply(A_u_tent, b)
            timer.completed("u1 construct rhs")

            iter = solve(A_u_tent, u1.vector(), b, *self.params.solver_u_tent)
            print "Iterations: ", iter
            timer.completed("u1 solve (%s, %d, %d)"%(', '.join(self.params.solver_u_tent), b.size(), iter))

            # Pressure correction
            b = assemble(L_p_corr)
            if len(bcp) == 0 or is_periodic(bcp):
                normalize(b)
            else:
                for bc in bcp: bc.apply(A_p_corr, b)
            timer.completed("p construct rhs")

            iter = solve(A_p_corr, p1.vector(), b, *solver_p_params)
            if len(bcp) == 0 or is_periodic(bcp): normalize(p1.vector())
            timer.completed("p solve (%s, %d, %d)"%(', '.join(solver_p_params), b.size(), iter))

            # Velocity correction
            assemble(a_u_corr, tensor=A_u_corr)
            b = assemble(L_u_corr)
            for bc in bcu: bc.apply(A_u_corr, b)
            timer.completed("u2 construct rhs")

            solver_params = self.params.solver_u_corr
            iter = solve(A_u_corr, u1.vector(), b, *solver_params)
            timer.completed("u2 solve (%s, %d, %d)"%(', '.join(solver_params), b.size(),iter))

            # Update postprocessing
            update(u1, p1, t, timestep)

            print "u-norm: ", norm(u1.vector())
            print "Pressure drop: ", max(p1.vector())-min(p1.vector())

            # Rotate functions for next timestep
            u0.assign(u1)
            p0.assign(p1)
