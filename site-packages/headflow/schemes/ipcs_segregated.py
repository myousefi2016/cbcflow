from __future__ import division

__author__ = "Joachim B Haga <jobh@simula.no>"
__date__ = "2012-02-15"
__copyright__ = "Copyright (C) 2012 " + __author__
__license__  = "GNU GPL version 3 or any later version"

from ..core.nsscheme import *
from ..core.rhsgenerator import *
from ..core.utils import epsilon, sigma, is_periodic

class SegregatedIPCS(NSScheme):
    "Segregated incremental pressure-correction scheme."

    def __init__(self, params):
        NSScheme.__init__(self, params)

    @classmethod
    def default_user_params(cls):
        params = ParamDict(segregated=True)
        return params

    def solve(self, problem, update, restart=None):
        #assert not problem.params.segregated

        # Get problem parameters
        mesh = problem.mesh
        dt, t, t_range = self.select_timestep(problem)

        # Define function spaces
        V = FunctionSpace(mesh, "CG", self.params.u_degree)
        Q = FunctionSpace(mesh, "CG", self.params.p_degree)

        # Get initial and boundary conditions
        u0, p0 = problem.initial_conditions(V, Q)
        bcu, bcp = self.fetch_bcs(problem, V,Q,t)
        
        u0 = [project(_, V) for _ in u0]
        u1 = [Function(V) for _u0 in u0]
        p0 = project(p0, Q)
        p1 = interpolate(p0, Q)
        
        # Remove boundary stress term if problem is periodic
        if is_periodic(bcp):
            beta = Constant(0)
        else:
            beta = Constant(1)  

        # Test and trial functions
        v = TestFunction(V)
        q = TestFunction(Q)
        u = TrialFunction(V)
        p = TrialFunction(Q)

        # Problem parameters etc
        nu = Constant(problem.mu/problem.rho)
        k  = Constant(dt)
        f  = problem.f
        n  = FacetNormal(mesh)

        dim  = len(u0)
        dims = range(dim)

        F_u_tent = []
        for d in dims:
            u_mean = 0.5 * (u + u0[d])
            u_diff = (u - u0[d])
            F_u_tent += [(1/k) * inner(v, u_diff) * dx
                         + v * sum(u0[r]*u0[d].dx(r) for r in dims) * dx
                         + inner(grad(v), nu*grad(u_mean)) * dx
                         - v.dx(d) * p0 * dx
                         + v * p0 * n[d] * ds
                         - v * f[d] * dx]
        # Tentative velocity
        a_u_tent = [lhs(F) for F in F_u_tent]
        L_u_tent = [rhs(F) for F in F_u_tent]

        # Pressure correction
        a_p_corr = inner(grad(q), grad(p))*dx
        L_p_corr = inner(grad(q), grad(p0))*dx - (1/k)*q*sum(u1[r].dx(r) for r in dims)*dx
        
        # Velocity correction
        a_u_corr = [inner(v, u)*dx for r in dims]
        L_u_corr = [v*u1[r]*dx - k*inner(v, grad(p1-p0)[r])*dx for r in dims]

        # Assemble matrices
        A_u_tent = [assemble(a) for a in a_u_tent]
        A_p_corr = assemble(a_p_corr)
        A_u_corr = [assemble(a) for a in a_u_corr]

        # Create solvers
        if len(bcp)==0 or is_periodic(bcp):
            solver_p_params = self.params.solver_p or self.params.solver_p_neumann
        else:
            solver_p_params = self.params.solver_p or self.params.solver_p_dirichlet

        solver_u_tent = LinearSolver(*self.params.solver_u_tent)
        solver_p_corr = LinearSolver(*solver_p_params)
        solver_u_corr = LinearSolver(*self.params.solver_u_corr)
        

        # Time loop
        self.start_timing()
        for timestep, t in enumerate(t_range):
            bcu, bcp = self.fetch_bcs(problem, V,Q,t)
            self.timer("update & fetch bc")

            # Solve tentative velocity
            for d in dims:
                b = assemble(L_u_tent[d])
                for bc in bcu: bc[d].apply(A_u_tent[d], b)
                    
                iter = solver_u_tent.solve(A_u_tent[d], u1[d].vector(), b)
                self.timer("u_tent solve (%s, %d dofs, %d iter)"%(', '.join(self.params.solver_u_tent), b.size(), iter))
                
            # Pressure correction
            b = assemble(L_p_corr)            
            if len(bcp) == 0 or is_periodic(bcp):
                normalize(b)
            else:
                for bc in bcp:
                    bc.apply(A_p_corr, b)
            self.timer("p_corr construct rhs")
            iter = solver_p_corr.solve(A_p_corr, p1.vector(), b)
            if len(bcp) == 0 or is_periodic(bcp): normalize(p1.vector())
            self.timer("p_corr solve (%s, %d dofs, %d iter)"%(', '.join(solver_p_params), b.size(), iter))

            # Velocity correction
            for d in dims:
                b = assemble(L_u_corr[d])
                for bc in bcu:
                    bc[d].apply(A_u_corr[d], b)
                
                self.timer("u_corr construct rhs")
                iter = solver_u_corr.solve(A_u_corr[d], u1[d].vector(), b)
                self.timer("u_corr solve (%s, %d dofs, %d iter)"%(', '.join(self.params.solver_u_corr), b.size(), iter))

            # Update
            update(u1, p1, t, timestep)
            for d in dims: u0[d].assign(u1[d])
            p0.assign(p1)

        return as_object(u_next), p_curr

    def __str__(self):
        name = "Segregated IPCS"
        return name
