from __future__ import division

__author__ = "Joachim B Haga <jobh@simula.no>"
__date__ = "2012-02-15"
__copyright__ = "Copyright (C) 2012 " + __author__
__license__  = "GNU GPL version 3 or any later version"

# Modified by Martin Alnaes, 2013. (added penalty bcs)

from ..core.nsoptscheme import *
from ..core.utils import Timer
from ..core.timesteps import compute_regular_timesteps

class SegregatedPenaltyIPCS(NSOptScheme):
    "Segregated incremental pressure-correction scheme with penalty terms for pressure BCs."

    def __init__(self, params):
        NSOptScheme.__init__(self, params, segregated=True)

    def solve(self, problem, update, restart=None):
        # Get spatial parameters
        mesh = problem.mesh
        dx = problem.dx
        ds = problem.ds
        dims = range(mesh.topology().dim())

        # Get time parameters
        dt, timesteps = compute_regular_timesteps(problem)
        t = Time(t0=timesteps[0])

        # Define function spaces
        V = FunctionSpace(mesh, "CG", self.params.u_degree)
        Q = FunctionSpace(mesh, "CG", self.params.p_degree)

        # Test and trial functions
        v = TestFunction(V)
        q = TestFunction(Q)
        u = TrialFunction(V)
        p = TrialFunction(Q)

        # Functions
        u0 = as_vector([Function(V, name="u0_%d"%d) for d in dims])
        u1 = as_vector([Function(V, name="u1_%d"%d) for d in dims])
        p0 = Function(Q, name="p0")
        p1 = Function(Q, name="p1")

        # Get control functions
        controls = problem.controls(V, Q)

        # Get initial conditions
        uinit, pinit = problem.initial_conditions(V, Q, controls)

        # Apply initial conditions
        for u0c, uic in zip(u0, uinit): u0c.assign(project(uic, V))
        p0.assign(project(pinit, Q))
        #assign(u0, uinit)
        #assign(p0, pinit)

        # Get boundary conditions
        bcu, bcp, a_p_corr_bc, L_p_corr_bc = self.build_bcs(problem, V, Q, t, controls)
        assert not (bcp and a_p_corr_bc), "Got both penalty and DBC versions of pressure BCs."

        # Problem parameters
        nu = Constant(problem.params.mu/problem.params.rho, name="nu")
        k  = Constant(dt, name="dt")
        f  = as_vector(problem.body_force(V))
        n  = FacetNormal(mesh)

        # Tentative velocity forms
        F_u_tent = []
        r = Index()
        for d in dims:
            u_mean = 0.5 * (u + u0[d])
            u_diff = (u - u0[d])
            F_u_tent += [(1/k) * inner(v, u_diff) * dx()
                         + v * u0[d].dx(r)*u0[r] * dx()
                         + inner(grad(v), nu*grad(u_mean)) * dx()
                         - v.dx(d) * p0 * dx()
                         + v * p0 * n[d] * ds()
                         - v * f[d] * dx()]
        a_u_tent = [lhs(F) for F in F_u_tent]
        L_u_tent = [rhs(F) for F in F_u_tent]

        # Pressure correction forms
        a_p_corr = inner(grad(q), grad(p))*dx() + a_p_corr_bc
        L_p_corr = inner(grad(q), grad(p0))*dx() - (1/k)*q*div(u1)*dx() + L_p_corr_bc

        # Velocity correction forms
        a_u_corr = [inner(v, u)*dx() for r in dims]
        L_u_corr = [v*u1[r]*dx() - k*inner(v, grad(p1-p0)[r])*dx() for r in dims]

        # Assemble matrices
        A_u_tent = [assemble(a) for a in a_u_tent]
        A_p_corr = assemble(a_p_corr)
        A_u_corr = [assemble(a) for a in a_u_corr]

        # Create solvers
        if self.params.solver_p:
            solver_p_params = self.params.solver_p
        elif len(bcp) == 0:
            solver_p_params = self.params.solver_p_neumann
        else:
            solver_p_params = self.params.solver_p_dirichlet

        # TODO: Is it ok to use KrylovSolver here? Do we need e.g. lu?
        #       LinearSolver did not work with dolfin-adjoint.
        solver_u_tent = KrylovSolver(*self.params.solver_u_tent)
        #solver_p_corr = KrylovSolver(*solver_p_params)
        solver_u_corr = KrylovSolver(*self.params.solver_u_corr)

        p_corr_problem = LinearVariationalProblem(a_p_corr, L_p_corr, p1, bcp)
        solver_p_corr = LinearVariationalSolver(p_corr_problem)
        solver_p_corr.parameters["linear_solver"], solver_p_corr.parameters["preconditioner"] = solver_p_params
        solver_p_corr.parameters["symmetric"] = True
        #solver_p_corr.solve() # Adding this line (which is a bug) causes the reported dolfin-adjoint warning

        # Profiling object
        timer = Timer(self.params.enable_timer)

        # Loop over fixed timesteps
        for timestep in xrange(1,len(timesteps)):
            assign_time(t, timesteps[timestep])

            # Update boundary condition functions
            problem.update_boundary_conditions(V, Q, t)
            timer.completed("update bcs")

            # Compute tentative velocity step
            for d in dims:
                b = assemble(L_u_tent[d])
                for bc in bcu: bc[d].apply(A_u_tent[d], b)
                timer.completed("u_tent construct rhs")

                iter = solver_u_tent.solve(A_u_tent[d], u1[d].vector(), b)
                timer.completed("u_tent solve (%s, %d dofs, %d iter)" % (
                    ', '.join(self.params.solver_u_tent), b.size(), iter))

            # Pressure correction
            if 0:
                b = assemble(L_p_corr)
                for bc in bcp: bc.apply(A_p_corr, b)
                timer.completed("p_corr construct rhs")

                iter = solver_p_corr.solve(A_p_corr, p1.vector(), b)
                timer.completed("p_corr solve (%s, %d dofs, %d iter)" % (
                    ', '.join(solver_p_params), b.size(), iter))
            else:
                solver_p_corr.solve()
                iter = -1
                timer.completed("p_corr solve (%s, %d dofs, %d iter)" % (
                    ', '.join(solver_p_params), b.size(), iter))

            # Velocity correction
            for d in dims:
                b = assemble(L_u_corr[d])
                for bc in bcu: bc[d].apply(A_u_corr[d], b)
                timer.completed("u_corr construct rhs")

                iter = solver_u_corr.solve(A_u_corr[d], u1[d].vector(), b)
                timer.completed("u_corr solve (%s, %d dofs, %d iter)" % (
                    ', '.join(self.params.solver_u_corr), b.size(), iter))

            # Rotate functions for next timestep
            for d in dims: u0[d].assign(u1[d])
            p0.assign(p1)

            # Update postprocessing
            update(u0, p0, float(t), timestep)

        # Return some quantities from the local namespace
        # TODO: The design of this is a bit ad-hoc...
        scope = {
            "V": V,
            "Q": Q,
            "controls": controls,
            "state": (u0, p0),
            "t": t,
            }
        return scope
