from __future__ import division

__author__ = "Oyvind Evju <oyvinev@simula.no>"
__date__ = "2013-04-30"
__copyright__ = "Copyright (C) 2013 " + __author__
__license__  = "GNU GPL version 3 or any later version"

from ..core.nsscheme import *
from ..core.rhsgenerator import *
from ..core.utils import Timer, epsilon, sigma, is_periodic
from ..core.timesteps import compute_regular_timesteps
from ..core.schemeutils import Spaces

class CoupledNonLinear(NSScheme):
    "Coupled scheme with fixed-point iterations on the convection term. NB: Direct solver!"

    def __init__(self, params):
        NSScheme.__init__(self, params, segregated=False)

    @classmethod
    def default_user_params(cls):
        # TODO: Clean up the generic nsscheme params here
        params = ParamDict(
            theta=0.5, #0.5: Crank-Nicholson, 1.0: Backward Euler, 0.0: Forward Euler
            fixed_point_tolerance=1e-6,
            max_fixed_point_iterations=500,
            )
        return params

    def solve(self, problem, update, restart=None):
        # Get problem parameters
        mesh = problem.mesh
        dt, timesteps = compute_regular_timesteps(problem)
        t = timesteps[0]
        dx = problem.dx
        ds = problem.ds

        # Define function spaces
        spaces = Spaces(mesh, self.params.u_degree, self.params.p_degree, "mixed")
        V = spaces.V
        Q = spaces.Q
        W = spaces.W

        # Get problem specific functions
        observations = problem.observations(spaces, t)
        controls = problem.controls(spaces)
        #ics = problem.initial_conditions(spaces, controls)
        #bcs = problem.boundary_conditions(spaces, u0, p0, t, controls)

        # Get initial and boundary conditions
        u0, p0 = problem.initial_conditions(V, Q)
        bcu, bcp = self.fetch_bcs(problem, u0, p0, t)

        U = Function(W)

        u0 = project(as_vector(u0), V)
        u1 = Function(V)
        p0 = project(p0, Q)
        p1 = interpolate(p0, Q)

        # Remove boundary stress term if problem is periodic
        if is_periodic(bcp):
            beta = Constant(0)
        else:
            beta = Constant(1)

        # Test and trial functions
        v, q = TestFunctions(W)
        u, p = TrialFunctions(W)

        # Problem parameters etc
        nu = Constant(problem.params.mu/problem.params.rho)
        k  = Constant(dt)
        f  = as_vector(problem.body_force(V))
        n  = FacetNormal(mesh)
                
        theta = self.params.theta

        a1 = 1.0/k*inner(u, v)*dx() +\
            theta*2*inner(nu*epsilon(u), epsilon(v))*dx() -\
            inner(p, div(v))*dx() -\
            inner(q, div(u))*dx()
        #a1 -= beta*theta*nu*inner(grad(u).T*n, v) * ds() # Unsure about the boundary terms
        a2 = theta*inner(grad(u)*u0, v)*dx()
        
        
        L = 1.0/k*inner(u0,v)*dx() -\
            (1-theta)*inner(grad(u0)*u0, v)*dx() -\
            (1-theta)*2*inner(nu*epsilon(u0), epsilon(v))*dx() +\
            dot(f,v)*dx()
        #L += beta*(1-theta)*nu*inner(grad(u).T*n, v) * ds() # Unsure about the boundary terms
        
        A = Matrix()
        A1 = assemble(a1)
        A2 = assemble(a2)
        A.assign(A1+A2)
        
        b = assemble(L)

        # Call update() with initial conditions
        update(u0, p0, float(t), 0)

        # Time loop
        timer = Timer(self.params.enable_timer)
        for timestep in xrange(1,len(timesteps)):
            t = timesteps[timestep]

            bcu, bcp = self.fetch_bcs(problem, u0, p0, t)
            
            timer.completed("update & fetch bc")
            
            assemble(L, tensor=b)
            for bc in bcu: bc.apply(b)
            for bc in bcp: bc.apply(b) 
            
            # Fixed point loop
            count = 0
            err = 1e16
            while err > self.params.fixed_point_tolerance:
                count += 1
                if count > self.params.max_fixed_point_iterations:
                    raise Exception("Fixed point iteration did not converge.")
                
                # Reassemble convection term
                assemble(a2, tensor=A2, reset_sparsity=False)
                
                A.assign(A1+A2)
                
                for bc in bcu: bc.apply(A)
                for bc in bcp: bc.apply(A)

                # TODO: Iterative solver
                #solve(A, U.vector(), b, "gmres", "ilu")
                solve(A, U.vector(), b)
                
                u1.assign(U.split()[0])
                p1.assign(U.split()[1])
                
                err = norm(u1.vector()-u0.vector())/norm(u1.vector())
                #print err
                u0.assign(u1)
                p0.assign(p1)
            print "Fixed point iteration converged in %d iterations. (err=%.4e)" %(count, err)            
            update(u0, p0, float(t), timestep)
