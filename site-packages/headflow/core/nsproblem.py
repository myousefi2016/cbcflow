from __future__ import division
__author__ = "Anders Logg <logg@simula.no>"
__date__ = "2008-03-19"
__copyright__ = "Copyright (C) 2008-2010 " + __author__
__license__  = "GNU GPL version 3 or any later version"

# Modified by Kent-Andre Mardal, 2008.

from dolfin import *
from math import *

from .paramdict import ParamDict
from .utils import parallel_eval, headflow_warning

# FIXME: This interface is up for a serious redesign now.

class NSProblem:
    "Base class for all Navier-Stokes problems."

    def __init__(self, params):
        self.params = self.default_params()
        self.params.update_recursive(params)

    @classmethod
    def default_problem_params(cls):
        "Subclasses should implement this to define problem specific parameters."
        return {}

    @classmethod
    def default_params(cls):
        # TODO: Store with structure params.common.* and params.specific.* or similar?
        # TODO: Clean up and insert generic nsproblem params here
        params = ParamDict(segregated=False,
                           output_location='.')
	params.update_recursive(cls.default_problem_params())
        return params

    def update_problem(self, t, u, p):
        "Update problem at time t"

        # Update state
        self.t = t
        self.u = u
        self.p = p

        # Call problem-specific update
        self.update(t, u, p)

    def update(self, t, u, p):
        "Problem-speficic update at time t"
        pass

    def functional(self, t, u, p):
        "Return value of functional of interest"
        return 0.0

    def reference(self, t):
        "Return reference value for functional"
        return None

    def tolerance(self, problem):
        "Return tolerance (used as local convergence criterion)."
        return 1e-6

    def preconditioner_name(self):
        "Return name of preconditioner."
        return "ilu"

    def pressure_bc(self, Q):
        headflow_warning("Using default pressure 0, please set pressure bc in boundary_conditions()")
        return Constant(0)

    def uConstant(self, values):
        if self.params.segregated and isinstance(values, tuple):
            return [Constant(v) for v in values]
        else:
            return [Constant(values)]

    def uExpr(self, cppcode, **kwargs):
        if self.params.segregated and isinstance(cppcode, (tuple, list)):
            return [Expression(e, **kwargs) for e in cppcode]
        else:
            return [Expression(cppcode, **kwargs)]

    def uEval(self, func, component, point):
        if self.params.segregated:
            return parallel_eval(func[component], point)
        else:
            return parallel_eval(func, point)[component]
