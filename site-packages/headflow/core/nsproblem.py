from __future__ import division
__author__ = "Martin Alnaes <martinal@simula.no> and Oeyvind Evju <oyvinev@simula.no>"
__date__ = "2013-04-26"
__copyright__ = "Copyright (C) 2013-2013 " + __author__
__license__  = "GNU GPL version 3 or any later version"

import ufl

from .paramdict import ParamDict
from .parameterized import Parameterized

class NSProblem(Parameterized):
    """Base class for all Navier-Stokes problems.

    TODO: Document new interface.
    """

    def __init__(self, params=None):
        Parameterized.__init__(self, params)

    @classmethod
    def default_base_params(cls):
        # TODO: Set parameters here that are expected by schemes.
        #       The below parameters are just suggestions, if enabled
        #       we should start using them in the demo problems.
        params = ParamDict(
            # Time parameters:
            T0=0.0, # Initial time (0 default is the common choice)
            T=None, # End time
            dt=None, # Timestep

            # Physical parameters:
            mu=None,    # Kinematic viscosity in [unit???]
            rho=None,    # Density in [unit???]
            )
        return params

    #@property
    #def mesh(self):
    #    "TODO: mesh property"
    #    raise NotImplementedError("A mesh property must be made available in subclass")

    def initial_conditions(self, V, Q):
        "TODO: Document expected initial_conditions behaviour here."
        raise NotImplementedError("initial_conditions must be overridden in subclass")

    def boundary_conditions(self, V, Q, t):
        "TODO: Document expected boundary_conditions behaviour here."
        raise NotImplementedError("boundary_conditions must be overridden in subclass")

    def body_force(self, V):
        "TODO: Document expected body_force behaviour here."
        d = self.mesh.topology().dim()
        return [Constant(0) for _ in xrange(d)]

    # TODO: An alternative to providing measures here is to provide domains through a uniform interface and let the schemes connect measures and domains
    @property
    def ds(self):
        return ufl.ds[self.mesh.domains().facet_domains()]

    @property
    def dS(self):
        return ufl.dS[self.mesh.domains().facet_domains()]

    @property
    def dx(self):
        return ufl.dx[self.mesh.domains().cell_domains()]

    def show(self, interactive=True, bc_snapshots=3):
        """Display properties of the problem.

        Intended for inspecting and debugging the problem setup.
        This functions runs through most of the interface
        """
        # Print params
        print("Problem parameters for problem of class %s:" % self.__class__.__name__)
        print(str(self.params))

        # Show the mesh
        plot(self.mesh, title="Mesh")

        # Show eventual boundary markers from mesh
        # TODO: Interface for specifying facet domains without mesh attachment?
        d = self.mesh.domains()
        if d is not None:
            fd = d.facet_domains()
            if fd is not None:
                plot(fd, title="Facet domains")

        # Make linear function spaces suitable for plotting
        V = VectorFunctionSpace(self.mesh, "CG", 1)
        Q = VectorFunctionSpace(self.mesh, "CG", 1)

        # Plot body force
        f = self.body_force(V)
        plot(f, title="Body force")

        # Plot initial conditions
        u0, p0 = self.initial_conditions(V, Q)
        plot(as_vector(u0), title="Initial velocity")
        plot(p0, title="Initial pressure")

        # Plot a few snapshots of boundary conditions
        for i in range(bc_snapshots):
            t = self.params.T0 + (self.params.T-self.params.T0)*i/(bc_snapshots-1)
            bcu, bcp = boundary_conditions(V, Q, t)

            # Plot velocity BCs
            for j, (u,D) in enumerate(bcu):
                D = "subdomain %d " if isinstance(D, int) else ""
                title = "Velocity BC #%d on %sat t=%g" % (j, D, t)
                plot(as_vector(u), title=title)

            # Plot pressure BCs
            for j, (p,D) in enumerate(bcp):
                D = "subdomain %d " if isinstance(D, int) else ""
                title = "Pressure BC #%d on %sat t=%g" % (j, D, t)
                plot(p, title=title)

        if interactive:
            import dolfin
            dolfin.interactive()
