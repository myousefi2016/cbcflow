from __future__ import division

__author__ = "Martin Alnaes <martinal@simula.no>"
__date__ = "2013-06-06"
__copyright__ = "Copyright (C) 2013 " + __author__
__license__  = "GNU GPL version 3 or any later version"

from ..dol import *

# --- Function space helper functions and classes for schemes

def element_args(suggested_family, degree):
    if suggested_family == "CG":
        if degree:
            return ("CG", degree)
        else:
            return ("DG", degree)
    if suggested_family == "DG":
        return ("DG", degree)
    if suggested_family == "CR":
        return ("CR", 1)
    return (suggested_family, degree)

class Spaces(object):
    def __init__(self, mesh, u_degree, p_degree, mode, u_family="CG", p_family="CG"):
        self.mode = mode

        # Dimensions
        self.d = mesh.ufl_cell().geometric_dimension()
        self.dims = range(self.d)

        # Make velocity spaces, both are useful in all modes
        self.U = FunctionSpace(mesh, *element_args(u_family, u_degree))
        self.V = VectorFunctionSpace(mesh, *element_args(u_family, u_degree))

        # Always make linear spaces for projecting to visualization files
        if (u_family, u_degree) == ("CG", 1):
            self.U_CG1 = self.U
            self.V_CG1 = self.V
        else:
            self.U_CG1 = FunctionSpace(mesh, "CG", 1)
            self.V_CG1 = VectorFunctionSpace(mesh, "CG", 1)

        # Make pressure space
        if p_degree == u_degree:
            self.Q = self.U
        else:
            self.Q = FunctionSpace(mesh, *element_args(p_family, p_degree))

        # Define relative subspaces to make DBCs:
        if mode == "mixed":
            # Mixed space is only needed in this mode
            self.W = self.V*self.Q

            self.Ubc = [self.W.sub(0).sub(d) for d in self.dims]
            self.Qbc = self.W.sub(1)

        elif mode == "split":
            self.Ubc = [self.V.sub(d) for d in self.dims]
            self.Qbc = self.Q

        elif mode == "segregated":
            self.Ubc = [self.U for d in self.dims]
            self.Qbc = self.Q

        else:
            error("Unknown mode %s" % mode)


# --- Initial condition helper functions for schemes

def assign_ics_mixed(up0, spaces, ics):
    up = as_vector(list(ics[0]) + [ics[1]])
    up0.assign(project2(up, spaces.W))

def assign_ics_split(u0, p0, spaces, ics):
    u = as_vector(list(ics[0]))
    p = ics[1]
    u0.assign(project2(u, spaces.V))
    p0.assign(project2(p, spaces.Q))

def assign_ics_segregated(u0, p0, spaces, ics):
    for d in spaces.dims:
        u0[d].assign(project2(ics[0][d], spaces.U))
    p0.assign(project2(ics[1], spaces.Q))


# --- Boundary condition helper functions for schemes

def _domainargs(problem, D):
    "Helper function to pass domain args if necessary."
    if isinstance(D, int):
        return (problem.facet_domains, D)
    else:
        return (D,)

def make_mixed_bcs(problem, spaces, bcs, v):
    bcu_raw, bcp_raw = bcs
    bcu = [DirichletBC(spaces.Ubc[d], functions[d], *_domainargs(problem, region))
           for functions, region in bcu_raw
           for d in spaces.dims]
    ds = problem.ds
    n = FacetNormal(problem.mesh)
    Lbc = -sum(dot(function*n, v)*ds(region) for (function, region) in bcp_raw)
    return bcu, Lbc

def make_velocity_bcs(problem, spaces, bcs):
    bcu_raw, bcp_raw = bcs
    bcu = [DirichletBC(spaces.Ubc[d], functions[d], *_domainargs(problem, region))
           for functions, region in bcu_raw
           for d in spaces.dims]
    return bcu

def make_segregated_velocity_bcs(problem, spaces, bcs):
    bcu_raw, bcp_raw = bcs
    bcu = [[DirichletBC(spaces.Ubc[d], functions[d], *_domainargs(problem, region))
            for d in spaces.dims]
           for functions, region in bcu_raw]
    return bcu

def make_pressure_bcs(problem, spaces, bcs):
    bcu_raw, bcp_raw = bcs
    bcp = [DirichletBC(spaces.Q, function, *_domainargs(problem, region))
           for function, region in bcp_raw]
    return bcp

def make_penalty_pressure_bcs(problem, spaces, bcs, gamma, test, trial):
    bcu_raw, bcp_raw = bcs

    # Define trial and test functions
    p = trial
    q = test
    Q = spaces.Q
    ds = problem.ds

    # Define Nitche discretization constants
    gamma = Constant(gamma, name="gamma")
    hE = Q.mesh().ufl_cell().max_facet_edge_length

    # The Nietche terms to integrate
    a_dirichlet = (gamma/hE)*(p*q) - Dn(p)*q - p*Dn(q)
    L_dirichlet = (gamma/hE)*q - Dn(q)

    # Collect Nietche terms for each subboundary
    a, L = [], []
    for pbc, D in bcp_raw:
        a += [    a_dirichlet*ds(D)]
        L += [pbc*L_dirichlet*ds(D)]

    # Accumulate and return both sides
    a_pbc = sum(a)
    L_pbc = sum(L)
    return a_pbc, L_pbc
