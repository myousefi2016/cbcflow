from __future__ import division
__author__ = "Oeyvind Evju <oyvinev@simula.no> and Martin Alnaes <martinal@simula.no>"
__date__ = "2013-04-26"
__copyright__ = "Copyright (C) 2013-2013 " + __author__
__license__  = "GNU GPL version 3 or any later version"

from ..dol import plot

from time import time

from .paramdict import ParamDict
from .parameterized import Parameterized
from .utils import get_memory_usage, time_to_string, headflow_print

class NSSolver(Parameterized):
    "High level Navier-Stokes solver."
    def __init__(self, problem, scheme=None, postprocessor=None, params=None):
        Parameterized.__init__(self, params)

        self.problem = problem
        self.scheme = scheme
        self.postprocessor = postprocessor

    @classmethod
    def default_base_params(cls):
        # TODO: Insert generic nssolver params here
        params = ParamDict(
            debug=False,
            plot_solution=False,
            check_mem_frequency=0,
            # restart = False, # Not yet supported
            # restart_time = 0.0, # Not yet supported
            # restart_timestep = 0, # Not yet supported
            )
        return params

    def solve(self):
        self._reset()

        # FIXME: Handle restart stuff, get from old ns script (see scratch/oldscripts/ns)
        # FIXME: Pick other details to reuse from old ns script, here or other places

        self.scheme.solve(self.problem, self.update)

        self._summarize()

    def _reset(self):
        self._initial_time = time()
        self._initial_memory = get_memory_usage()

        self._time = time()
        self._accumulated_time = 0

    def _summarize(self):
        self._final_time = time()
        self._final_memory = get_memory_usage()

        msg = "Total time spent in NSSolver: %s" % time_to_string(self._final_time - self.initial_time)
        headflow_print(msg)

        msg = "Memory usage before solve: %s\nMemory usage after solve: %s" % (
            self._initial_memory,
            self._final_memory)
        headflow_print(msg)

    def _update_timing(self, timestep, t, time_at_top):
        # Time since last update equals the time for scheme solve
        solve_time = time_at_top - self._time

        # Store time for next update
        self._time = time()

        # Time since time at top of update equals postproc + some update overhead
        pp_time = self._time - time_at_top

        # Accumulate time spent for time left estimation
        if timestep > 1:
            # (skip first step where jit compilation dominates)
            self._accumulated_time += solve_time
            self._accumulated_time += pp_time
        if timestep == 2:
            # (count second step twice to compensate for skipping first) (this may be overkill)
            self._accumulated_time += solve_time
            self._accumulated_time += pp_time

        # Report timing of this step
        msg = ("Timestep %5d finished (t=%.2e, %.1f%%) in %3.1fs (solve: %3.1fs). Time spent: %s Time remaining: %s" \
                                       % (timestep, t,
                                          100*t/self.problem.T,
                                          solve_time + pp_time,
                                          solve_time,
                                          time_to_string(self._accumulated_time),
                                          time_to_string(self._accumulated_time*(self.problem.T-t)/t),
                                          ))
        # TODO: Report to file, with additional info like memory usage, and make reporting configurable
        headflow_print(msg)

    def _update_memory(self, timestep):
        fr = self.params.check_mem_frequency
        if fr > 0 and timestep % fr == 0:
            # TODO: Report to file separately for each process
            headflow_print('Memory usage is: %s' % get_memory_usage())

    def _update_plot(self, u, p):
        if self.params.plot_solution:
            plot(u, title="Velocity")
            plot(p, title="Pressure")

    def update(self, u, p, t, timestep):
        # Make a record of when update was called
        time_at_top = time()

        # Run postprocessor
        if self.postprocessor:
            self.postprocessor.update_all(u, p, t, timestep, self.problem)

        # Plot solution
        self._update_plot(u, p)

        # Check memory usage
        self._update_memory(timestep)

        # Update timing data
        self._update_timing(timestep, t, time_at_top)
