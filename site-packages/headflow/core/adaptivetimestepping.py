from __future__ import division
__author__ = "Oeyvind Evju <oyvinev@simula.no>"
__date__ = "2013-05-23"
__copyright__ = "Copyright (C) 2013-2013 " + __author__
__license__  = "GNU GPL version 3 or any later version"

from .parameterized import Parameterized
from .paramdict import ParamDict
from ..dol import Constant

# TODO: Make base class, there's a bit of shared code here
class AdaptiveTimestepping(Parameterized): # TODO: Better name is AdaptiveTimeStepper
    def __init__(self, params=None):
        Parameterized.__init__(self, params)
        self.t = Constant(self.params.T0 + self.dt, name="TIME") # FIXME: Should be just T0 initially, this is inconsistent!
        self.timestep = self.params.timestep0 + 1 # FIXME: Should be just timestep0 initially, this is inconsistent!

        self.dt = self.params.dt

        self.T = self.params.T
        self.T0 = self.params.T0

        self.last_modified_timestep = self.timestep
        self.previous_check_value = None

    @classmethod
    def default_base_params(cls):
        params = ParamDict(
            # Timestep check parameters
            min_value = 15,
            max_value = 40,
            decrease_factor = 2.0,
            increase_factor = 1.5,
            min_timesteps_between_increases = 5,
            increase_on_positive_gradient = False,

            # Time parameters
            T = 1,
            dt = 1e-4,

            # Parameters for restart
            T0 = 0,
            timestep0 = 0,
            )
        return params

    def time(self):
        return self.t

    def current_timestep(self):
        return self.timestep

    def __iter__(self):
        return self

    def next(self):
        eps = 1e-12
        if float(self.t) - self.dt <= self.T - eps:
            return self.timestep
        else:
            raise StopIteration

    def set_timestep(self, timestep):
        self.timestep = timestep

    def get_dt(self):
        return self.dt

    def adjusted_timestep(self, check_value):
        #import ipdb; ipdb.set_trace()
        #print check_value
        increased = False
        decreased = False

        dt = self.dt

        if check_value > self.params.max_value:
            self.dt = self.dt / self.params.decrease_factor
            self.last_modified_timestep = self.timestep
            decreased = True

        increase1 = (check_value < self.params.min_value)
        increase2 = (self.timestep - self.last_modified_timestep > self.params.min_timesteps_between_increases)
        if not self.params.increase_on_positive_gradient or self.previous_check_value != None:
            increase3 = (check_value <= self.previous_check_value)
        else:
            increase3 = True

        if increase1 and increase2 and increase3:
            self.dt = self.dt * self.params.increase_factor
            self.last_modified_timestep = self.timestep
            increased = True

        self.previous_check_value = check_value

        if decreased:
            # Adjust self.t to new self.dt
            self.t.assign(float(self.t) - dt + self.dt)
        else:
            # Timestep accepted or increased
            self.timestep += 1
            self.t.assign(float(self.t) + dt)

        is_modified = (decreased or increased)

        #if not is_modified:
        #    self.timestep += 1
        #    self.t.assign(float(self.t) + self.dt)
        #print is_modified
        #print "hei", self.timestep, float(self.t)

        return (is_modified, self.dt)
