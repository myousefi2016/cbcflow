from __future__ import division
__author__ = "Martin Alnaes <martinal@simula.no>"
__date__ = "2013-05-04"
__copyright__ = "Copyright (C) 2013-2013 " + __author__
__license__  = "GNU GPL version 3 or any later version"

from ..dol import *

from .utils import headflow_print, as_scalar_spaces
from .paramdict import ParamDict
from .nsscheme import NSScheme

class NSOptScheme(NSScheme):
    def __init__(self, params=None, segregated=False):
        NSScheme.__init__(self, params, segregated=segregated)

    @classmethod
    def default_user_params(cls):
        params = ParamDict(
            use_penalty_pressure_bcs=True,
            penalty_gamma=50.0,
            )
        return params

    def build_pressure_penalty_bc_forms(self, problem, Q, bcp_raw):

        # Define trial and test functions (get (mesh,p,q) as input instead of Q?)
        p = TrialFunction(Q)
        q = TestFunction(Q)
        ds = problem.ds

        # Define Nitche discretization constants
        gamma = Constant(self.params.penalty_gamma, name="gamma")
        hE = Q.mesh().ufl_cell().max_facet_edge_length

        # The Nietche terms to integrate
        a_dirichlet = (gamma/hE)*(p*q) - Dn(p)*q - p*Dn(q)
        L_dirichlet = (gamma/hE)*q - Dn(q)

        # Collect Nietche terms for each subboundary
        a = []
        L = []
        for (pbc, D) in bcp_raw:
            a += [     a_dirichlet*ds(D) ]
            L += [ pbc*L_dirichlet*ds(D) ]
        return sum(a), sum(L)

    def build_bcs(self, problem, V, Q, t, controls):
        """Get dirichlet boundary conditions.

        Translates boundary conditions returned by problem
        into the right format for this scheme.

        Returns (bcu, bcp, a, L) where
        - bcu, bcp are lists of DirichletBC instances
        - a, L are forms to add to the pressure equation
        """

        bcu_raw, bcp_raw = problem.boundary_conditions(V, Q, t, controls)

        # Pass facet domains if necessary
        def domainargs(D):
            if isinstance(D, int):
                return (problem.facet_domains, D)
            else:
                return (D,)

        # Define velocity BCs in spaces or subspaces
        # depending on segregation choice in scheme
        Vsub = as_scalar_spaces(V)

        bcu = []
        for fs, D in bcu_raw:
            # Build list of bcs for scalar components
            bclist = [DirichletBC(Vsub[i], f, *domainargs(D)) for i,f in enumerate(fs)]

            # Store differently based on segregation choice in scheme
            if self._segregated:
                # bcu = [ [uxbc1, uybc1, uzbc1], [uxbc1, uybc1, uzbc1], ...]
                bcu.append(bclist)
            else:
                # bcu = [uxbc1, uybc1, uzbc1, uxbc1, uybc1, uzbc1]
                bcu.extend(bclist) # TODO: I think we can get rid of this by iterating over components in non-segregated schemes

        # Define pressure BCs depending on penalty method choice in scheme
        # TODO: This if-sentence and the in/out-interface are now the only differences between build_bcs and fetch_bcs
        if self.params.use_penalty_pressure_bcs:
            a, L = self.build_pressure_penalty_bc_forms(problem, Q, bcp_raw)
            bcp = []
        else:
            a, L = 0, 0
            # Define dirichlet pressure BCs
            bcp = []
            for f, D in bcp_raw:
                bcp.append(DirichletBC(Q, f, *domainargs(D)))

        return bcu, bcp, a, L
