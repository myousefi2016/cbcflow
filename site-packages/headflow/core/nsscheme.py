__author__ = "Anders Logg <logg@simula.no>"
__date__ = "2008-04-03"
__copyright__ = "Copyright (C) 2008-2010 " + __author__
__license__  = "GNU GPL version 3 or any later version"

from dolfin import *

from time import time
import os
from numpy import linspace

from .utils import headflow_print, getMyMemoryUsage
from .utils import fmt, as_object, check_divergence
from .paramdict import ParamDict
from .parameterized import Parameterized

master = MPI.process_number() == 0

# FIXME: Move stuff that's not scheme-related out of this class and file

class NSScheme(Parameterized):
    "Base class for all Navier-Stokes schemes."

    def __init__(self, params=None):
        Parameterized.__init__(self, params)

        # Reset some solver variables
        self._time = None
        self._cputime = 0.0
        self._timestep = 0

        # Reset files for storing solution
        self._ufiles = None
        self._pfile  = None

        # Reset storage for functional values and errors
        self._t = []
        self._M = []
        self._m = []
        self._e = []

        self._timer = None
        self._func_cache = {}

    @classmethod
    def default_base_params(cls):
        # TODO: Clean up the generic nsscheme params here
        params = ParamDict(
            # TODO: Clean up segregated stuff. Making it a parameter of both scheme and problem, must match.
            segregated=False,

            # TODO: Does timestepping belong in solver or problem?
            dt_division=0,
            dt=None,

            # TODO: These should maybe be postprocessor parameters?
            casedir="results",
            save_solution=False,
            save_frequency=100,
            save_number=None, # max number of saves in total, at fixed frequency
            save_solution_at_final_t=False,
            save_xml=False,
            plot_solution=False,
            plot_functional=False,

            # TODO: These should maybe be nssolver parameters?
            check_mem_usage=False,
            check_mem_frequency=10,
            check_divergence=False,
            enable_timer=False,

            # TODO: These ipcs solvers are scheme specific and should maybe not be here,
            #       but they are used by many of the splitting schemes
            # TODO: Split these into separate parameters for solver/preconditioner
            solver_u_tent=("gmres", "hypre_euclid"),
            solver_p_neumann=("gmres", "hypre_amg"),
            solver_p_dirichlet=("gmres", "ml_amg"),
            solver_p=None, # overrides neumann/dirichlet if given
            solver_u_corr=("bicgstab", "hypre_euclid"),
            )
        return params

    def timer(self, msg):
        if self.params.enable_timer and master:
            print "%10.0f ms: %s"%((time()-self._timer)*1000, msg)
            self._timer = time()

    def start_timing(self):
        """Start timing, will be paused automatically during update
        and stopped when the end-time is reached."""
        self._time = time()
        self._timer = time()

    def solve(self, problem, dt, plot_solution=True):
        "Solve problem"
        raise NotImplementedError

    def prefix(self, problem):
        "Return file prefix for output files"
        p = problem.__module__.split(".")[-1].lower()
        s = self.__module__.split(".")[-1].lower()
        return problem.params.output_location + p + "_" + s

    def desegregate(self, u):
        if not isinstance(u, (list, tuple)):
            return u
        if len(u) == 1:
            return u[0]
        assert MPI.num_processes() == 1
        V = u[0].function_space()
        W = VectorFunctionSpace(V.mesh(), V.ufl_element().family(), V.ufl_element().degree())
        f = self._func_cache.setdefault(str(W), Function(W))
        fv = f.vector()
        for i in range(len(u)):
            uv = u[i].vector()
            # FIXME: Assumptions about ordering of vector-function entries
            fv[i*len(uv):(i+1)*len(uv)] = uv
        return f

    def update(self, problem, t, u, p):
        "Update problem at time t"

        casedir = self.params.casedir
        u = as_object(u)

        if problem.params.segregated:
           s = max(ui.vector().norm('linf') for ui in u)
        else:
           s = u.vector().norm('linf')
        if s > 5 * getattr(problem, 'U', float('inf')):
            warning("A component in u is %.4g times characteristic velocity U"%round(s))
        if s > 1e10:
            raise RuntimeError("Runaway solution")

        # Add to accumulated CPU time
        timestep_cputime = time() - self._time
        self._cputime += timestep_cputime

        # Compute divergence
        if self.params.check_divergence:
            check_divergence(u, p.function_space())

        # Update problem FIXME: Should this be called before problem.functional??
        problem.update_problem(t, u, p)

        # Evaluate functional and error
        m = problem.reference(t)
        M = problem.functional(t, u, p)
        if m is None:
            e = None
            headflow_print("M = %s (missing reference value)" % fmt(M))
        else:
            e = abs(M - m)
            headflow_print("M = %s (reference %s), error = %s (maximum %g)" % (
                    fmt(M), fmt(m), fmt(e), max([e] + self._e)))

        # Store values
        self._t.append(t)
        self._M.append(M)
        self._m.append(m)
        self._e.append(e)

        # Save solution
        if self.params.save_solution:
            if (self._timestep - 1) % self.params.save_frequency == 0:
                # Create files
                if self._ufiles is None:
                    if problem.params.segregated:
                        # added '_' to separate i from vtu numbering
                        self._ufiles = [File(os.path.join(casedir, "u%d_.pvd" % i), "compressed")
                                        for i in range(len(u))]
                    else:
                        self._ufiles = File(os.path.join(casedir, "u.pvd"), "compressed")
                if self._pfile is None:
                    self._pfile = File(os.path.join(casedir, "p.pvd"), "compressed")

                # Write to files
                if problem.params.segregated:
                    for i, ui in enumerate(u):
                        self._ufiles[i] << ui
                else:
                    self._ufiles << u
                self._pfile << p

        # Save solution at t = T
        if self.params.save_solution_at_final_t:
            if t >= problem.T:
                # Create files
                if self._ufiles is None:
                    self._ufiles = [File(os.path.join(casedir, "u%d_at_end.pvd" % i), "compressed")
                                    for i in range(len(u))]
                else:
                    self._ufiles = File(os.path.join(casedir, "u_at_end.pvd"), "compressed")
                if self._pfile is None:
                    self._pfile = File(os.path.join(casedir, "p_at_end.pvd"), "compressed")

                # Write to files
                if problem.params.segregated:
                    for i, ui in enumerate(u):
                        self._ufiles[i] << ui
                else:
                    self._ufiles << u
                self._pfile << p

        # Save vectors in xml format
        if self.params.save_xml:
            if (self._timestep - 1) % self.params.save_frequency == 0:
                timestr = "at_t%d_%.6e" % (self._timestep, t)
                if problem.params.segregated:
                    for i, ui in enumerate(u):
                        file = File(os.path.join(casedir, "u%d_%s.xml.gz" % (i, timestr)))
                        file << ui.vector()
                else:
                    file = File(os.path.join(casedir, "u_%s.xml.gz" % (timestr,)))
                    file << u.vector()
                file = File(os.path.join(casedir, "p_%s.xml.gz" % (timestr,)))
                file << p.vector()

        # Plot solution
        if self.params.plot_solution:
            # Plot velocity and pressure
            plot(self.desegregate(u), title="Velocity", rescale=True)
            plot(p, title="Pressure", rescale=True)

        # Check memory usage
        if self.params.check_mem_usage:
            if (self._timestep - 1) % self.params.check_mem_frequency == 0:
                print 'Memory usage is:' , getMyMemoryUsage()

        # Print progress
        if master:
            ss = self._cputime * (problem.T/t-1)
            hh, ss = divmod(ss, 60*60)
            mm, ss = divmod(ss, 60)
            print
            s = "Time step %d finished in %.2f seconds, %.1f%% done (t=%.3g, T=%g; %02d:%02d:%02d remaining)." \
                % (self._timestep, timestep_cputime, 100.0*(t / problem.T), t, problem.T, hh, mm, ss)
            print s
            print "-"*len(s)

        # Increase time step and record current time
        self._timestep += 1
        self._time = time()

    def select_timestep(self, problem):
        "Return time step and number of time steps for problem."

        # FIXME: This looks very complex, should be cleaned up

        T  = problem.T
        U  = getattr(problem, "U", float("nan"))
        nu = problem.nu
        h  = MPI.min(problem.mesh.hmin())

        try:
            # FIXME: This sequence of ifs make no sense. Clean up...

            if self.params.dt:
                headflow_print("Using user supplied dt")
                dt = self.params.dt
                n = int(T / dt + 0.5)
                dt = T / n

            elif self.params.dt_division != 0 and getattr(problem, "dt", 0) > 0:
                headflow_print('Using problem.dt and time step refinements')
                dt = problem.dt / int(sqrt(2)**self.params.dt_division)
                n  = int(T / dt + 1.0)
                dt = T / n

            # Use time step specified in problem if available
            elif getattr(problem, "dt", 0) > 0:
                headflow_print('Using problem.dt')
                dt = problem.dt
                n  = int(T / dt)

            # Otherwise, base time step on mesh size
            elif self.params.dt_division != 0:
                headflow_print('Computing time step according to stability criteria and time step refinements')
                dt = 0.25*h**2 / (U*(nu + h*U))
                dt /= int(sqrt(2)**self.params.dt_division)
                n  = int(T / dt + 1.0)
                dt = T / n

            # Otherwise, base time step on mesh size
            else:
                headflow_print('Computing time step according to stability criteria')
                # dt =  0.25*h**2 / (U*(nu + h*U))
                dt =  0.2*(h / U)
                n  = int(T / dt + 1.0)
                dt = T / n

        finally:
            if dt != dt:
                warning("Unable to compute dt. Please set U in problem, or specify dt in params")

        # Compute range
        t_range = linspace(0,T,n+1)[1:] # FIXME: Comment out [1:] to run g2ref g2ref

        # Compute save_frequency if save_number is given
        if self.params.save_number is not None:
            frequency = int(1 + len(t_range) / (1+self.params.save_number))
            headflow_print("Selected save frequency of %d (total %d snapshots)" % (
                            frequency, len(t_range)//frequency))
            self.params.save_frequency = frequency

        # Report time step
        if master:
            print " "
            print 'Number of timesteps:' , len(t_range)
            print 'Size of timestep:' , dt
            print " "

        self._num_steps = len(t_range)
        return dt, t_range[0], t_range

    def eval(self):
        "Return last functional value and maximum error in functional value on [0, T]"

        # Plot values
        if self.params.plot_functional:
            from pylab import plot, xlabel, ylabel, grid, show
            plot(self._t, self._M)
            xlabel('t')
            ylabel('Functional')
            grid(True)
            show()

        # Return value
        if self._e[0] is None:
            return self._M[-1], None
        else:
            return self._M[-1], max([0.0] + self._e)

    def cputime(self):
        "Return accumulated CPU time."
        return self._cputime
