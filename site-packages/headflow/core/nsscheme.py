__author__ = "Anders Logg <logg@simula.no>"
__date__ = "2008-04-03"
__copyright__ = "Copyright (C) 2008-2010 " + __author__
__license__  = "GNU GPL version 3 or any later version"

from dolfin import *

from time import time
import os
from numpy import linspace

from .utils import headflow_print
from .paramdict import ParamDict
from .parameterized import Parameterized

master = MPI.process_number() == 0

class NSScheme(Parameterized):
    """Base class for all Navier-Stokes schemes.

    FIXME: Clean up and document new interface.
    """

    def __init__(self, params, segregated):
        Parameterized.__init__(self, params)

        # Store fixed segregated property
        self._segregated = segregated

        # Reset some timing variables
        self._timer = None # TODO: Move to nssolver

    @classmethod
    def default_base_params(cls):
        # TODO: Clean up the generic nsscheme params here
        params = ParamDict(
            # Discretization parameters
            u_degree = 2,
            p_degree = 1,

            # TODO: These ipcs solvers are scheme specific and should maybe not be here,
            #       however they are used by most of the splitting schemes...
            # TODO: Split these into separate parameters for solver/preconditioner
            solver_u_tent=("gmres", "hypre_euclid"),
            solver_p_neumann=("gmres", "hypre_amg"),
            solver_p_dirichlet=("gmres", "ml_amg"),
            solver_p=None, # overrides neumann/dirichlet if given
            solver_u_corr=("bicgstab", "hypre_euclid"),

            # TODO: Move to nssolver
            enable_timer=False,
            )
        return params

    ###### Scheme name functions

    @classmethod
    def shortname(cls):
        "Get a one-word description of the scheme. By default uses class name."
        return cls.__name__

    @classmethod
    def description(cls):
        "Get a one-sentence description of the scheme. By default uses first line of class docstring."
        return cls.__doc__.split('\n')[0]

    def __str__(self):
        return self.description()

    ###### Main solve interface

    def solve(self, problem, dt, plot_solution=True):
        "Solve Navier-Stokes problem by executing scheme."
        raise NotImplementedError("Scheme must implement solve method!")

    def fetch_bcs(self, problem, V, Q, t):
        "Fetch boundary conditions from problem and translate into the right format for this scheme."

        bcu_raw, bcp_raw = problem.boundary_conditions(V, Q, t)

        if self._segregated:
            bcu = []
            for bc in bcu_raw:
                bcu.append([DirichletBC(V, bc[0][i], bc[1]) for i in xrange(len(bc[0]))])
        else:
            bcu = [DirichletBC(V, as_vector(bc[0]), bc[1]) for bc in bcu_raw]

        bcp = [DirichletBC(Q, bc[0], bc[1]) for bc in bcp_raw]

        return bcu, bcp


    ###### Timer functions (TODO: Move to nssolver)

    def timer(self, msg):
        t = time()
        if self.params.enable_timer:
            headflow_print("%10.0f ms: %s" % ((t - self._timer)*1000, msg))
        self._timer = t

    def start_timing(self):
        """Start timing, will be paused automatically during update
        and stopped when the end-time is reached."""
        self._timer = time()
