__author__ = "Anders Logg <logg@simula.no>"
__date__ = "2008-04-03"
__copyright__ = "Copyright (C) 2008-2010 " + __author__
__license__  = "GNU GPL version 3 or any later version"

from dolfin import *

from time import time
import os
from numpy import linspace

from .utils import headflow_print
from .paramdict import ParamDict
from .parameterized import Parameterized

master = MPI.process_number() == 0

class NSScheme(Parameterized):
    """Base class for all Navier-Stokes schemes.

    FIXME: Clean up and document new interface.
    """

    def __init__(self, params, segregated):
        Parameterized.__init__(self, params)

        # Store fixed segregated property
        self._segregated = segregated

        # Reset some timing variables
        self._timer = None

        # Reset files for storing solution
        self._ufiles = None
        self._pfile  = None

        self._func_cache = {}

    @classmethod
    def default_base_params(cls):
        # TODO: Clean up the generic nsscheme params here
        params = ParamDict(
            # TODO: Does timestepping belong in solver or problem?
            dt_division=0,
            dt=None,

            # TODO: These should maybe be nssolver parameters?
            enable_timer=False,

            # TODO: These ipcs solvers are scheme specific and should maybe not be here,
            #       but they are used by many of the splitting schemes
            # TODO: Split these into separate parameters for solver/preconditioner
            solver_u_tent=("gmres", "hypre_euclid"),
            solver_p_neumann=("gmres", "hypre_amg"),
            solver_p_dirichlet=("gmres", "ml_amg"),
            solver_p=None, # overrides neumann/dirichlet if given
            solver_u_corr=("bicgstab", "hypre_euclid"),

            # Discretization parameters
            u_degree = 2,
            p_degree = 1,
            )
        return params

    ###### Scheme name functions

    @classmethod
    def shortname(cls):
        "Get a one-word description of the scheme. By default uses class name."
        return cls.__name__

    @classmethod
    def description(cls):
        "Get a one-sentence description of the scheme. By default uses first line of class docstring."
        return cls.__doc__.split('\n')[0]

    def __str__(self):
        return self.description()

    ###### Main solve interface

    def solve(self, problem, dt, plot_solution=True):
        "Solve Navier-Stokes problem by executing scheme."
        raise NotImplementedError("Scheme must implement solve method!")

    def fetch_bcs(self, problem, V, Q, t):
        "Fetch boundary conditions from problem and translate into the right format for this scheme."

        bcu_raw, bcp_raw = problem.boundary_conditions(V, Q, t)

        if self._segregated:
            bcu = []
            for bc in bcu_raw:
                bcu.append([DirichletBC(V, bc[0][i], bc[1]) for i in xrange(len(bc[0]))])
        else:
            bcu = [DirichletBC(V, as_vector(bc[0]), bc[1]) for bc in bcu_raw]

        bcp = [DirichletBC(Q, bc[0], bc[1]) for bc in bcp_raw]

        return bcu, bcp


    ###### Timer functions (TODO: Move to nssolver)

    def timer(self, msg):
        if self.params.enable_timer and master:
            print "%10.0f ms: %s"%((time()-self._timer)*1000, msg)
            self._timer = time()

    def start_timing(self):
        """Start timing, will be paused automatically during update
        and stopped when the end-time is reached."""
        self._timer = time()


    ###### Various old functionality (TODO: clean up!)

    def select_timestep(self, problem):
        "Return time step and number of time steps for problem."

        # FIXME: This looks very complex, should be cleaned up

        T  = problem.T
        U  = getattr(problem, "U", float("nan"))
        nu = problem.mu/problem.rho
        #nu = problem.nu
        h  = MPI.min(problem.mesh.hmin())

        try:
            # FIXME: This sequence of ifs make no sense. Clean up...

            if self.params.dt:
                headflow_print("Using user supplied dt")
                dt = self.params.dt
                n = int(T / dt + 0.5)
                dt = T / n

            elif self.params.dt_division != 0 and getattr(problem, "dt", 0) > 0:
                headflow_print('Using problem.dt and time step refinements')
                dt = problem.dt / int(sqrt(2)**self.params.dt_division)
                n  = int(T / dt + 1.0)
                dt = T / n

            # Use time step specified in problem if available
            elif getattr(problem, "dt", 0) > 0:
                headflow_print('Using problem.dt')
                dt = problem.dt
                n  = int(T / dt)

            # Otherwise, base time step on mesh size
            elif self.params.dt_division != 0:
                headflow_print('Computing time step according to stability criteria and time step refinements')
                dt = 0.25*h**2 / (U*(nu + h*U))
                dt /= int(sqrt(2)**self.params.dt_division)
                n  = int(T / dt + 1.0)
                dt = T / n

            # Otherwise, base time step on mesh size
            else:
                headflow_print('Computing time step according to stability criteria')
                # dt =  0.25*h**2 / (U*(nu + h*U))
                dt =  0.2*(h / U)
                n  = int(T / dt + 1.0)
                dt = T / n

        finally:
            if dt != dt:
                warning("Unable to compute dt. Please set U in problem, or specify dt in params")

        # Compute range
        t_range = linspace(0,T,n+1)[1:] # FIXME: Comment out [1:] to run g2ref g2ref

        ''' # Removed
        # Compute save_frequency if save_number is given
        if self.params.save_number is not None:
            frequency = int(1 + len(t_range) / (1+self.params.save_number))
            headflow_print("Selected save frequency of %d (total %d snapshots)" % (
                            frequency, len(t_range)//frequency))
            self.params.save_frequency = frequency
        '''
        # Report time step
        if master:
            print " "
            print 'Number of timesteps:' , len(t_range)
            print 'Size of timestep:' , dt
            print " "

        self._num_steps = len(t_range)
        return dt, t_range[0], t_range
