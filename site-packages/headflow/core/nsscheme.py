from __future__ import division
__author__ = "Martin Alnaes <martinal@simula.no> and Oeyvind Evju <oyvinev@simula.no>"
__date__ = "2013-04-26"
__copyright__ = "Copyright (C) 2013-2013 " + __author__
__license__  = "GNU GPL version 3 or any later version"

from ..dol import *

from time import time
import os
from numpy import linspace

from .utils import headflow_print, as_scalar_spaces
from .paramdict import ParamDict
from .parameterized import Parameterized

master = MPI.process_number() == 0
'''
# Temporary(?) classes for workaround the problem described in fetch_bcs
class VectorExpression3D(Expression):
    def __init__(self, exp_list):
        self.exp_list = exp_list
        self.D = 3

    def eval(self, value, x):
        for i in xrange(self.D):
            self.exp_list[i].eval(value[i:i+1], x)

    def value_shape(self):
        return (3, )

class VectorExpression2D(Expression):
    def __init__(self, exp_list):
        self.exp_list = exp_list
        self.D = 2

    def eval(self, value, x):
        for i in xrange(self.D):
            self.exp_list[i].eval(value[i:i+1], x)

    def value_shape(self):
        return (2, )
'''





class NSScheme(Parameterized):
    """Base class for all Navier-Stokes schemes.

    TODO: Clean up and document new interface.
    """

    def __init__(self, params, segregated):
        Parameterized.__init__(self, params)

        # Store fixed segregated property
        self._segregated = segregated

    @classmethod
    def default_base_params(cls):
        # TODO: Clean up the generic nsscheme params here
        params = ParamDict(
            # TODO: Move to nssolver?
            enable_timer=False,

            # TODO: If these are to be generic scheme params,
            #       they should be used in most or all solvers:
            # Discretization parameters
            u_degree = 2,
            p_degree = 1,

            # TODO: These ipcs solvers are scheme specific and should maybe not be here,
            #       however they are used by most of the splitting schemes...
            # TODO: Split these into separate parameters for solver/preconditioner?
            solver_u_tent=("gmres", "hypre_euclid"),
            solver_p_neumann=("gmres", "hypre_amg"),
            solver_p_dirichlet=("gmres", "ml_amg"),
            solver_p=None, # overrides neumann/dirichlet if given
            solver_u_corr=("bicgstab", "hypre_euclid"),
            )
        return params

    def solve(self, problem, dt, plot_solution=True):
        "Solve Navier-Stokes problem by executing scheme."
        raise NotImplementedError("Scheme must implement solve method!")

    #def fetch_bcs(self, problem, V, Q, t):
    def fetch_bcs(self, problem, u, p, t):
        """Get boundary conditions.

        bcu_raw, bcp_raw = problem.boundary_conditions(V, Q, t)
        if not self.params.segregated:
            # as_vector(bc[0]) inside DirichletBC is horribly slow (seemingly evaluation in all dofs)
            #bcu = [DirichletBC(V, as_vector(bc[0]), bc[1]) for bc in bcu_raw]
            # Temporary work-around
            if V.mesh().geometry().dim() == 3:
                bcu = [DirichletBC(V, VectorExpression3D(bc[0]), bc[1]) for bc in bcu_raw]
            elif V.mesh().geometry().dim() == 2:
                bcu = [DirichletBC(V, VectorExpression2D(bc[0]), bc[1]) for bc in bcu_raw]

        else:
            bcu = []
            for bc in bcu_raw:
                bcu.append([DirichletBC(V, bc[0][i], bc[1]) for i in xrange(len(bc[0]))])

        bcp = [DirichletBC(Q, bc[0], bc[1]) for bc in bcp_raw]

        return bcu, bcp

        Translates boundary conditions returned by problem
        into the right format for this scheme.

        Returns bcu, bcp, where each is a list of DirichletBC
        instances."""

        #bcu_raw, bcp_raw = problem.boundary_conditions(V, Q, t)
	bcu_raw, bcp_raw = problem.boundary_conditions(u, p, t)

        # Pass facet domains if necessary
        def domainargs(D):
            if isinstance(D, int):
                return (problem.facet_domains, D)
            else:
                return (D,)

        # Define velocity BCs in spaces or subspaces
        # depending on segregation choice in scheme
	try:
	    V = u.function_space()
	except:
	    V = u[0].function_space()
	    
	Q = p.function_space()
	    
	
        Vsub = as_scalar_spaces(V)

        bcu = []
        for fs, D in bcu_raw:
            # Build list of bcs for scalar components
            bclist = [DirichletBC(Vsub[i], f, *domainargs(D)) for i,f in enumerate(fs)]

            # Store differently based on segregation choice in scheme
            if self._segregated:
                # bcu = [ [uxbc1, uybc1, uzbc1], [uxbc1, uybc1, uzbc1], ...]
                bcu.append(bclist)
            else:
                # bcu = [uxbc1, uybc1, uzbc1, uxbc1, uybc1, uzbc1]
                bcu.extend(bclist) # TODO: I think we can get rid of this by iterating over components in non-segregated schemes

        # Define dirichlet pressure BCs
        bcp = []
        for f, D in bcp_raw:
            bcp.append(DirichletBC(Q, f, *domainargs(D)))

        return bcu, bcp
