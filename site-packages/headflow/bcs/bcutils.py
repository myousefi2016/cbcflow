from ..dol import *
import numpy as np

def compute_boundary_geometry_acrn(mesh, ind, facet_domains):
    # Some convenient variables
    assert facet_domains is not None
    dsi = ds[facet_domains](ind)
    cell = mesh.ufl_cell()
    d = cell.d
    x = cell.x

    # Compute area of boundary tesselation by integrating 1.0 over all facets
    A = assemble(Constant(1.0)*dsi, mesh=mesh)
    assert A > 0.0, "Expecting positive area, probably mismatch between mesh and markers!"

    # Compute barycenter by integrating x components over all facets
    c = [assemble(x[i]*dsi, mesh=mesh) / A for i in xrange(d)]

    # Compute average normal (assuming boundary is actually flat)
    n = FacetNormal(mesh)
    ni = [assemble(n[i]*dsi, mesh=mesh) for i in xrange(d)]
    n_len = np.sqrt(sum(ni[i]**2 for i in xrange(d))) # Should always be 1!?
    normal = [ni[i]/n_len for i in xrange(d)]

    # Compute points on boundary
    #xx = ...

    # Compute radius (assuming boundary points are on exact geometry)
    r2str = " + ".join("(x[%d]-c%d)*(x[%d]-c%d)" % (i,i,i,i) for i in xrange(d))
    cargs = { 'c%d'%i: c[i] for i in xrange(d) }
    re = Expression("sqrt(%s)" % r2str, **cargs)
    #interpolate(re)
    # FIXME: r = sup(re, dsi)
    r = np.sqrt(A / pi)

    return A, c, r, normal

def compute_area(mesh, ind, facet_domains):
    # Some convenient variables
    assert facet_domains is not None
    dsi = ds[facet_domains](ind)

    # Compute area of boundary tesselation by integrating 1.0 over all facets
    A = assemble(Constant(1.0)*dsi, mesh=mesh)
    assert A > 0.0, "Expecting positive area, probably mismatch between mesh and markers!"
    return A

def compute_transient_scale_value(bc, period, mesh, facet_domains, ind, scale_value):
    dsi = ds[facet_domains](ind)
    form = sqrt(as_vector(bc)**2) * dsi

    N = 100
    qt = [0]*N
    for i, t in enumerate(linspace(0, period, N)):
        for e in bc:
            e.set_t(t)
        qt[i] = assemble(form, mesh=mesh)
    for e in bc:
        e.set_t(0.0)

    q_avg = sum(qt) / len(qt)
    return scale_value / q_avg
