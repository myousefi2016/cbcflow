from ..dol import *

def get_area(mesh, ind, facet_domains=None):
    # TODO: Always require facet_domains
    if facet_domains is None:
        dim = mesh.geometry().dim()
        facet_domains = MeshFunction("size_t", mesh, dim-1, mesh.domains())
        assert facet_domains is not None, "Assuming a mesh with attached facet domains!"
    dsi = ds[facet_domains](ind)

    A = assemble(Constant(1.0)*dsi, mesh=mesh)
    assert A > 0.0, "Expecting positive area, probably mismatch between mesh and markers!"

    return A

def _old_get_center(mesh, ind):
    dim = mesh.geometry().dim()
    fd = MeshFunction("size_t", mesh, dim-1, mesh.domains())
    assert fd is not None, "Assuming a mesh with attached facet domains!"
    dsi = ds[fd](ind)

def get_center(mesh, ind, facet_domains=None):
    # TODO: Always require facet_domains
    if facet_domains is None:
        dim = mesh.geometry().dim()
        facet_domains = MeshFunction("size_t", mesh, dim-1, mesh.domains())
        assert facet_domains is not None, "Assuming a mesh with attached facet domains!"
    dsi = ds[facet_domains](ind)

    A = assemble(Constant(1.0)*dsi, mesh=mesh)
    assert A > 0.0, "Expecting positive area, probably mismatch between mesh and markers!"

    cell = mesh.ufl_cell()
    d = cell.d
    x = cell.x
    center = [assemble(x[i]*dsi, mesh=mesh) / A for i in xrange(d)]
    return center

def _old_get_average_normal(mesh, ind):
    dim = mesh.geometry().dim()
    fd = MeshFunction("size_t", mesh, dim-1, mesh.domains())
    assert fd is not None, "Assuming a mesh with attached facet domains!"
    dsi = ds[fd](ind)

def get_average_normal(mesh, ind, facet_domains=None):
    # TODO: Always require facet_domains
    if facet_domains is None:
        dim = mesh.geometry().dim()
        facet_domains = MeshFunction("size_t", mesh, dim-1, mesh.domains())
        assert facet_domains is not None, "Assuming a mesh with attached facet domains!"
    dsi = ds[facet_domains](ind)

    n = FacetNormal(mesh)
    d = len(n)
    ni = [assemble(n[i]*dsi, mesh=mesh) for i in xrange(d)]
    n_len = sqrt(sum(ni[i]**2 for i in xrange(d))) # Should be 1?
    normal = [ni[i]/n_len for i in xrange(d)]

    return normal

def compute_transient_scale_value(bc, period, mesh, facet_domains, ind, scale_value):
    dsi = ds[facet_domains](ind)
    form = sqrt(as_vector(bc)**2) * dsi

    N = 100
    qt = [0]*N
    for i, t in enumerate(linspace(0, period, N)):
        for e in bc:
            e.set_t(t)
        qt[i] = assemble(form, mesh=mesh)
    for e in bc:
        e.set_t(0.0)

    q_avg = sum(qt) / len(qt)
    return scale_value / q_avg
