#from ..dol import assemble, Constant, ds, FunctionSpace, Function, DirichletBC, Expression, sqrt
from ..dol import *
from numpy import linspace


def get_area(mesh, ind):
    dim = mesh.geometry().dim()
    fd = MeshFunction("size_t", mesh, dim-1, mesh.domains())
    
    assert fd is not None, "Assuming a mesh with attached facet domains!"
    dsi = ds[fd](ind)

    A = assemble(Constant(1.0)*dsi, mesh=mesh)
    assert A > 0.0, "Expecting positive area, probably mismatch between mesh and markers!"

    return A


def get_center(mesh, ind):
    dim = mesh.geometry().dim()
    fd = MeshFunction("size_t", mesh, dim-1, mesh.domains())
    assert fd is not None, "Assuming a mesh with attached facet domains!"
    dsi = ds[fd](ind)

    A = assemble(Constant(1.0)*dsi, mesh=mesh)
    assert A > 0.0, "Expecting positive area, probably mismatch between mesh and markers!"

    x = mesh.ufl_cell().x
    center = [assemble(x[i]*dsi, mesh=mesh) / A for i in xrange(3)]
    return center


def get_average_normal(mesh, ind):
    dim = mesh.geometry().dim()
    fd = MeshFunction("size_t", mesh, dim-1, mesh.domains())
    assert fd is not None, "Assuming a mesh with attached facet domains!"
    dsi = ds[fd](ind)

    n = FacetNormal(mesh)
    x = assemble(n[0]*dsi, mesh=mesh)
    y = assemble(n[1]*dsi, mesh=mesh)
    z = assemble(n[2]*dsi, mesh=mesh)
    xyz_len = sqrt(x**2+y**2+z**2)
    normal = [x/xyz_len, y/xyz_len, z/xyz_len]
    return normal


class BC_base(object):
    def __init__(self):
        pass

    def _update(self, t, u):
        return

    def set_t(self, t):
        self.t = t-floor(t/self.period)*self.period

    def scale(self, scale_value):
        N = 100
        qt = [0]*100
        for i, t in enumerate(linspace(0, self.period, 100)):
            for e in self: e.set_t(t)

            qt[i] = assemble(sqrt(self[0]**2+self[1]**2+self[2]**2)*ds(self.ind), mesh=self.mesh, exterior_facet_domains=self.mesh.domains().facet_domains())

        for e in self: e.set_t(0.0)

        q_avg = sum(qt)/len(qt)
        scale_value = scale_value/q_avg

        return scale_value
