#from dolfin import assemble, Constant, ds, FunctionSpace, Function, DirichletBC, Expression, sqrt
from dolfin import *
from numpy import linspace


def area_and_center(mesh, ind):
    fd = mesh.domains().facet_domains()
    assert fd is not None, "Assuming a mesh with attached facet domains!"

    #fd2 = mesh.data().mesh_function("exterior facet domains")
    #assert fd2 is not None, "Assuming a mesh with attached facet domains!"
    '''
    print
    print
    print ind
    print sum(1 if i else 0 for i in fd.array() == ind)
    u = fd.array().max()
    import numpy
    wh = numpy.where(fd.array() == u)
    for i in wh[0]:
        fd[i] = 3
    plot(fd)
    interactive()
    print
    print
    '''
    A = assemble(Constant(1.0)*ds(ind), mesh=mesh, exterior_facet_domains=fd)
    assert A > 0.0, "Expecting positive area, probably mismatch between mesh and markers!"

    V = FunctionSpace(mesh, "CG", 1)
    x = mesh.ufl_cell().x
    center = [assemble(x[i]*ds(ind), mesh=mesh, exterior_facet_domains=fd) / A for i in xrange(3)]
    return A, center

def find_average_normal(mesh, ind):
    fd = mesh.domains().facet_domains()
    
    n = FacetNormal(mesh)
    x = assemble(n[0]*ds(ind), mesh=mesh, exterior_facet_domains=fd)
    y = assemble(n[1]*ds(ind), mesh=mesh, exterior_facet_domains=fd)
    z = assemble(n[2]*ds(ind), mesh=mesh, exterior_facet_domains=fd)
    xyz_len = sqrt(x**2+y**2+z**2)
    normal = [x/xyz_len, y/xyz_len, z/xyz_len]
    return normal

class BC_base(object):
    def __init__(self):
        pass

    def _update(self, t, u):
        return

    def set_t(self, t):
        self.t = t-floor(t/self.period)*self.period
        
    def scale(self, scale_value):
        N = 100
        qt = [0]*100
        for i, t in enumerate(linspace(0, self.period, 100)):
            for e in self: e.set_t(t)
            
            qt[i] = assemble(sqrt(self[0]**2+self[1]**2+self[2]**2)*ds(self.ind), mesh=self.mesh, exterior_facet_domains=self.mesh.domains().facet_domains())
            print t, qt[i]
        
        for e in self: e.set_t(0.0)
        
        
        q_avg = sum(qt)/len(qt)
        scale_value = scale_value/q_avg

        return scale_value
        
    '''    
    def get_scale_value(self, scale_value, scale_mode, degree):
        # TODO: Fix scale value.
        if scale_value == None:
            return 1.0
        if scale_mode != "flux":
            raise NotImplementedError("Scale mode %s has not been implemented" %scale_mode)

        V = VectorFunctionSpace(self.mesh, "CG", degree)
        u = Function(V)

        qt = []
        for t in linspace(0, self.period, 100):
            for e in self:
                e.set_t(t)

            expr = VectorExpression(self[0], self[1], self[2])

            bc = DirichletBC(V, expr, self.ind)
            bc.apply(u.vector())

            n = FacetNormal(self.mesh)
            qt.append(assemble(dot(u,n)*ds(self.ind)))
            print qt[-1]
        q_avg = sum(qt)/len(qt)
        scale_value = scale_value/q_avg
        return scale_value
    
    '''