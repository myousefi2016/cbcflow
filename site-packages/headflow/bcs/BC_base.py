#from ..dol import assemble, Constant, ds, FunctionSpace, Function, DirichletBC, Expression, sqrt
from ..dol import *
from numpy import linspace

def get_area(mesh, ind, facet_domains=None):
    # TODO: Always require facet_domains
    if facet_domains is None:
        dim = mesh.geometry().dim()
        facet_domains = MeshFunction("size_t", mesh, dim-1, mesh.domains())
        assert facet_domains is not None, "Assuming a mesh with attached facet domains!"
    dsi = ds[facet_domains](ind)

    A = assemble(Constant(1.0)*dsi, mesh=mesh)
    assert A > 0.0, "Expecting positive area, probably mismatch between mesh and markers!"

    return A

def get_center(mesh, ind):
    dim = mesh.geometry().dim()
    fd = MeshFunction("size_t", mesh, dim-1, mesh.domains())
    assert fd is not None, "Assuming a mesh with attached facet domains!"
    dsi = ds[fd](ind)

def get_center(mesh, ind, facet_domains=None):
    # TODO: Always require facet_domains
    if facet_domains is None:
        dim = mesh.geometry().dim()
        facet_domains = MeshFunction("size_t", mesh, dim-1, mesh.domains())
        assert facet_domains is not None, "Assuming a mesh with attached facet domains!"
    dsi = ds[facet_domains](ind)

    A = assemble(Constant(1.0)*dsi, mesh=mesh)
    assert A > 0.0, "Expecting positive area, probably mismatch between mesh and markers!"

    cell = mesh.ufl_cell()
    d = cell.d
    x = cell.x
    center = [assemble(x[i]*dsi, mesh=mesh) / A for i in xrange(d)]
    return center

def get_average_normal(mesh, ind):
    dim = mesh.geometry().dim()
    fd = MeshFunction("size_t", mesh, dim-1, mesh.domains())
    assert fd is not None, "Assuming a mesh with attached facet domains!"
    dsi = ds[fd](ind)

def get_average_normal(mesh, ind, facet_domains=None):
    # TODO: Always require facet_domains
    if facet_domains is None:
        dim = mesh.geometry().dim()
        facet_domains = MeshFunction("size_t", mesh, dim-1, mesh.domains())
        assert facet_domains is not None, "Assuming a mesh with attached facet domains!"
    dsi = ds[facet_domains](ind)

    n = FacetNormal(mesh)
    d = len(n)
    ni = [assemble(n[i]*dsi, mesh=mesh) for i in xrange(d)]
    n_len = sqrt(sum(ni[i]**2 for i in xrange(d))) # Should be 1?
    normal = [ni[i]/n_len for i in xrange(d)]

    return normal


class BC_base(object):
    def __init__(self):
        pass

    def _update(self, t, u):
        return

    def set_t(self, t):
        self.t = t % self.period

    def scale(self, scale_value):
        N = 100
        qt = [0]*100
        for i, t in enumerate(linspace(0, self.period, 100)):
            for e in self: e.set_t(0.0)
            qt[i] = assemble(sqrt(self[0]**2+self[1]**2+self[2]**2)*ds(self.ind),
                             mesh=self.mesh, exterior_facet_domains=self.facet_domains)

        for e in self: e.set_t(0.0)

        q_avg = sum(qt)/len(qt)
        return scale_value / q_avg
