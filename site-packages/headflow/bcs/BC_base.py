#from ..dol import assemble, Constant, ds, FunctionSpace, Function, DirichletBC, Expression, sqrt
from ..dol import *
from numpy import linspace


def area_and_center(mesh, ind):
    fd = mesh.domains().facet_domains()
    assert fd is not None, "Assuming a mesh with attached facet domains!"
    dsi = ds[fd](ind)

    '''
    print
    print
    print ind
    print sum(1 if i else 0 for i in fd.array() == ind)
    u = fd.array().max()
    import numpy
    wh = numpy.where(fd.array() == u)
    for i in wh[0]:
        fd[i] = 3
    plot(fd)
    interactive()
    print
    print
	'''
    A = assemble(Constant(1.0)*dsi, mesh=mesh)
    assert A > 0.0, "Expecting positive area, probably mismatch between mesh and markers!"

    V = FunctionSpace(mesh, "CG", 1)
    x = mesh.ufl_cell().x
    center = [assemble(x[i]*dsi, mesh=mesh) / A for i in xrange(3)]
    return A, center

def find_average_normal(mesh, ind):
    fd = mesh.domains().facet_domains()
    assert fd is not None, "Assuming a mesh with attached facet domains!"
    dsi = ds[fd](ind)

    n = FacetNormal(mesh)
    x = assemble(n[0]*dsi, mesh=mesh)
    y = assemble(n[1]*dsi, mesh=mesh)
    z = assemble(n[2]*dsi, mesh=mesh)
    xyz_len = sqrt(x**2+y**2+z**2)
    normal = [x/xyz_len, y/xyz_len, z/xyz_len]
    return normal

class BC_base(object):
    def __init__(self):
        pass

    def _update(self, t, u):
        return

    def set_t(self, t):
        self.t = t-floor(t/self.period)*self.period
        
    def scale(self, scale_value):
        N = 100
        qt = [0]*100
        for i, t in enumerate(linspace(0, self.period, 100)):
            for e in self: e.set_t(t)
            
            qt[i] = assemble(sqrt(self[0]**2+self[1]**2+self[2]**2)*ds(self.ind), mesh=self.mesh, exterior_facet_domains=self.mesh.domains().facet_domains())
        
        for e in self: e.set_t(0.0)
        
        
        q_avg = sum(qt)/len(qt)
        scale_value = scale_value/q_avg

        return scale_value
