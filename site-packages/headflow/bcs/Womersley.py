
from ..dol import *

import numpy as np

from scipy.interpolate import UnivariateSpline
from scipy.integrate import simps
from scipy.special import jn

from .bcutils import get_area, get_center, get_average_normal, compute_transient_scale_value

def fourier_coefficients(x, y, T, N=25):
    '''From x-array and y-spline and period T, calculate N complex Fourier coefficients.'''
    omega = 2*pi/T
    ck = []
    ck.append(1/T*simps(y(x), x))
    for n in range(1,N):
        c = 1/T*simps(y(x)*np.exp(-1j*n*omega*x), x)
        ck.append(2*c)
    return ck

class _WomersleyExpression(Expression):
    # Subclassing the expression class restricts the number of arguments, args is therefore a dict of arguments.
    def __init__(self, args): # TODO: Document args properly
        Expression.__init__(self)

        # Spatial args
        self.radius = args["radius"]
        self.center = args["center"]
        self.normal_component = args["normal_component"]

        # Temporal args
        self.period = args["period"]
        self.Qn = args["Qn"]

        # Physical args
        nu = args["nu"]

        # Internal state
        self.t = 0.0
        self.scale_value = 1.0

        # Precomputation
        self.N = len(self.Qn)
        self.calculate_bessel_functions(self.N, self.radius, self.period, nu)
        self.all_sum_terms = {}

    def calculate_bessel_functions(self, N, a, T, nu):
        '''Calculate the Bessel functions of the Womersley profile'''

        # TODO: Is this the same in 2D?

        self.omega = 2*pi/T
        self.beta = [0+0j]*N
        self.jn0_betas = [0+0j]*N
        self.jn1_betas = [0+0j]*N

        for n in xrange(1, self.N):
            alfa_n = a*np.sqrt(self.omega*n/nu)
            self.beta[n] = alfa_n*np.sqrt(1j**3)
            self.jn0_betas[n] = jn(0, self.beta[n])
            self.jn1_betas[n] = jn(1, self.beta[n])

    def get_sum_terms(self, x):
        c = self.center
        d = len(c)

        # Look for cached womersley terms
        key = tuple(x[i] for i in xrange(d))
        sum_terms = self.all_sum_terms.get(key)
        if sum_terms is None:
            # Cache miss! Perform initial computation.

            # Compute scaled radius from x
            r = np.sqrt(sum((x[i]-c[i])**2 for i in xrange(d)))
            y = r / self.radius
            pir2 = pi * self.radius**2

            # Compute intermediate terms for womersley function
            sum_terms = np.zeros(self.N, dtype=np.complex)
            sum_terms[0] = 2*self.Qn[0]*(1-y**2) / pir2
            for n in xrange(1, self.N):
                sum_terms[n] = self.Qn[n] / pir2
                sum_terms[n] *= ( (1.0 - jn(0, self.beta[n]*y)/self.jn0_betas[n])
                                 /(1.0 - 2.0*self.jn1_betas[n]/(self.beta[n]*self.jn0_betas[n])) )

            # Cache it for this coordinate
            self.all_sum_terms[key] = sum_terms

        return sum_terms

    def set_t(self, t):
        self.t = t % self.period

    def eval(self, value, x):
        # Compute scalar value in flow direction
        sum_terms = self.get_sum_terms(x)
        val = sum_terms[0]
        for n in xrange(1, self.N):
            val += np.exp(1j*self.omega*n*self.t)*sum_terms[n]
        val = val.real

        # Output scaled value for this negative normal direction
        value[0] = -self.scale_value * self.normal_component * val


class Womersley(list):
    '''
    Generates a list of expressions in the form of a Womersley profile.
    '''
    #def __init__(self, coeffs, mesh, indicator, method='peak', scale_value=None, scale_mode='flux'):
    #def __init__(self, coeffs, mesh, indicator, nu, scale_value=None, scale_mode='flux'):
    def __init__(self, coeffs, mesh, indicator, nu, scale_to=None, facet_domains=None):
        assert(isinstance(mesh, Mesh))

        # TODO: Always require facet_domains
        if facet_domains is None:
            dim = mesh.geometry().dim()
            facet_domains = MeshFunction("size_t", mesh, dim-1, mesh.domains())
            assert facet_domains is not None, "Missing facet domains!"

        # Find radius and center
        A = get_area(mesh, indicator, facet_domains)
        center = get_center(mesh, indicator, facet_domains)
        radius = np.sqrt(A/pi)

        # Get normal
        normal = get_average_normal(mesh, indicator, facet_domains)

        # Coefficients of velocity profile
        x,y = zip(*coeffs)
        x = np.array(x)
        y = np.array(y)

        period = max(x)

        # Get a highly resolved function of the input by linear interpolation
        f = UnivariateSpline(x,y,k=1, s=0)
        xx = np.linspace(0, period, 1001)

        Qn = fourier_coefficients(xx, f, period)

        # Create Expressions
        d = len(normal)
        expressions = []
        for i in xrange(d):
            args = {
                "normal_component": normal[i],
                "radius": radius,
                "center": center,
                "Qn": Qn,
                "period": period,
                "nu": nu,
                }
            expressions.append(_WomersleyExpression(args))

        if scale_to is not None:
            scale_factor = compute_transient_scale_value(expressions, period,
                                                         mesh, facet_domains, indicator,
                                                         scale_value)
            for e in expressions:
                e.scale_value = scale_factor

        # TODO: Don't need this class, just make it a function to return expressions instead
        #self.mesh = mesh
        #self.ind = indicator
        #self.facet_domains = facet_domains
        #self.period = period
        self.extend(expressions)
