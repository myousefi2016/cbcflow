
from ..dol import *

import numpy as np

from scipy.interpolate import UnivariateSpline
from scipy.integrate import simps
from scipy.special import jn

from itertools import izip
from .bcutils import get_area, get_center, get_average_normal, compute_transient_scale_value

def fourier_coefficients(x, y, T, N=25):
    '''From x-array and y-spline and period T, calculate N complex Fourier coefficients.'''
    omega = 2*pi/T
    ck = []
    ck.append(1/T*simps(y(x), x))
    for n in range(1,N):
        c = 1/T*simps(y(x)*np.exp(-1j*n*omega*x), x)
        ck.append(2*c)
    return ck

class _WomersleyExpression(Expression):
    # Subclassing the expression class restricts the number of arguments, args is therefore a dict of arguments.
    def __init__(self, args): # TODO: Document args properly
        Expression.__init__(self)

        # Spatial args
        self.radius = args["radius"]
        self.center = args["center"]
        self.normal_component = args["normal_component"]

        # Temporal args
        self.period = args["period"]
        self.Qn = args["Qn"]

        # Physical args
        self.nu = args["nu"]

        # Internal state
        self.t = 0.0
        self.scale_value = 1.0

        # Precomputation
        self._precompute_bessel_functions()
        self._all_x_dependent_coeffs = {}

    def _precompute_bessel_functions(self):
        '''Calculate the Bessel functions of the Womersley profile'''
        self.N = len(self.Qn)
        self.ns = np.arange(1, self.N)
        self.omega = 2 * pi / self.period
        self.beta = np.zeros(self.N, dtype=np.complex)
        self.jn0_betas = np.zeros(self.N, dtype=np.complex)
        self.jn1_betas = np.zeros(self.N, dtype=np.complex)

        for n in self.ns:
            alfa_n = self.radius * np.sqrt(self.omega * n / self.nu)
            self.beta[n] = alfa_n * np.sqrt(1j**3)
            self.jn0_betas[n] = jn(0, self.beta[n])
            self.jn1_betas[n] = jn(1, self.beta[n])

    def _precompute_x_dependent_coeffs(self, x):
        # Compute scaled radius from x
        r = np.sqrt(sum((xi-ci)**2 for xi,ci in izip(x,self.center)))
        y = r / self.radius
        pir2 = pi * self.radius**2

        # Compute intermediate terms for womersley function
        x_dependent_coeffs = np.zeros(self.N, dtype=np.complex)
        x_dependent_coeffs[0] = 2*self.Qn[0]*(1-y**2) / pir2
        for n in self.ns:
            x_dependent_coeffs[n] = self.Qn[n] / pir2
            x_dependent_coeffs[n] *= ( (1.0 - jn(0, self.beta[n]*y)/self.jn0_betas[n])
                                   /(1.0 - 2.0*self.jn1_betas[n]/(self.beta[n]*self.jn0_betas[n])) )
        return x_dependent_coeffs

    def _get_x_dependent_coeffs(self, x):
        "Look for cached womersley coeffs."
        key = tuple(x)
        x_dependent_coeffs = self._all_x_dependent_coeffs.get(key)
        if x_dependent_coeffs is None:
            # Cache miss! Compute coeffs for this coordinate the first time.
            x_dependent_coeffs = self._precompute_x_dependent_coeffs(x)
            self._all_x_dependent_coeffs[key] = x_dependent_coeffs
        return x_dependent_coeffs

    def set_t(self, t):
        self.t = t % self.period

    def eval(self, value, x):
        # Compute or get cached complex coefficients that only depend on x
        x_dependent_coeffs = self._get_x_dependent_coeffs(x)

        # Multiply complex coefficients with complex exponential functions in time
        expn = np.exp((self.omega * self.t * 1j) * self.ns)
        val = (x_dependent_coeffs[0] + np.dot(expn, x_dependent_coeffs[1:])).real

        # Output scaled value for this negative normal direction
        value[0] = -self.scale_value * self.normal_component * val


class Womersley(list):
    '''
    Generates a list of expressions in the form of a Womersley profile.
    '''
    #def __init__(self, coeffs, mesh, indicator, method='peak', scale_value=None, scale_mode='flux'):
    #def __init__(self, coeffs, mesh, indicator, nu, scale_value=None, scale_mode='flux'):
    def __init__(self, coeffs, mesh, indicator, nu, scale_to=None, facet_domains=None):
        assert(isinstance(mesh, Mesh))

        # TODO: Always require facet_domains
        if facet_domains is None:
            dim = mesh.geometry().dim()
            facet_domains = MeshFunction("size_t", mesh, dim-1, mesh.domains())
            assert facet_domains is not None, "Missing facet domains!"

        # Compute radius, center and normal vector
        area = get_area(mesh, indicator, facet_domains)
        radius = np.sqrt(area / pi)
        center = get_center(mesh, indicator, facet_domains)
        normal = get_average_normal(mesh, indicator, facet_domains)

        # Compute transient profile as interpolation of given coefficients
        x,y = zip(*coeffs)
        x = np.array(x)
        y = np.array(y)
        period = max(x)
        transient_profile = UnivariateSpline(x, y, s=0, k=1)

        # Compute fourier coefficients of transient profile
        timedisc = np.linspace(0, period, 1001)
        Qn = fourier_coefficients(timedisc, transient_profile, period)

        # Create Expressions for each direction
        expressions = []
        for ncomp in normal:
            args = {
                "radius": radius,
                "center": center,
                "normal_component": ncomp,
                "period": period,
                "Qn": Qn,
                "nu": nu,
                }
            expressions.append(_WomersleyExpression(args))

        # Apply scaling w.r.t. peak transient profile (FIXME: This is unclear!)
        if scale_to is not None:
            scale_factor = compute_transient_scale_value(expressions, period,
                                                         mesh, facet_domains, indicator,
                                                         scale_value)
            for e in expressions:
                e.scale_value = scale_factor

        # TODO: Don't need this class, just make it a function to return expressions instead
        #self.mesh = mesh
        #self.ind = indicator
        #self.facet_domains = facet_domains
        #self.period = period
        self.extend(expressions)
