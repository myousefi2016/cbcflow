
from dolfin import *
from numpy import floor, array, sqrt, exp, linspace
from scipy.interpolate import UnivariateSpline
#from scipy import integrate
from scipy.integrate import simps
from scipy.special import jn
from BC_base import BC_base, area_and_center, find_average_normal

from time import time

def fourier_coefficients(x, y, T, N=25):
    '''From x-array and y-spline and period T, calculate N complex Fourier coefficients.'''
    omega = 2*pi/T
    ck = []
    ck.append(1/T*simps(y(x), x))
    for n in range(1,N):
        c = 1/T*simps(y(x)*exp(-1j*n*omega*x), x)
        ck.append(2*c)
    return ck



class _WomersleyExpression(Expression):
    #def __init__(self, normal_component, radius, center, velocity_profile, period): # Subclassing the expression class restricts the number of arguments, args is therefore a dict of arguments.
    def __init__(self, args):
        Expression.__init__(self)

        self.a = args["radius"]
        self.center = args["center"]
        self.Qn = args["Qn"]
        self.period = args["period"]
        self.normal_component = args["normal_component"]
        nu = args["nu"]

        self.N = len(self.Qn)

        self.t = 0.0
        self.scale_value = 1.0

        self.calculate_bessel_functions(self.N, self.a, self.period, nu)

    def calculate_bessel_functions(self, N, a, T, nu):
        '''Calculate the Bessel functions of the Womersley profile'''
        self.omega = 2*pi/T
        self.beta = [0+0j]*N
        self.jn0_betas = [0+0j]*N
        self.jn1_betas = [0+0j]*N

        for n in range(1,self.N):
            alfa_n = a*sqrt(self.omega*n/nu)
            self.beta[n] = alfa_n*sqrt(1j**3)
            self.jn0_betas[n] = jn(0, self.beta[n])
            self.jn1_betas[n] = jn(1, self.beta[n])


    def set_t(self, t):
        self.t = t-floor(t/self.period)*self.period

    def _set_scale_value(self, scale_value):
        self.scale_value = scale_value

    def eval(self, value, x):
	# TODO: Massive speed up desired (C++-implementation?)
        # Calculate Womersley profile
	
	t1 = time()
	
        r = sqrt((x[0]-self.center[0])**2+(x[1]-self.center[1])**2+(x[2]-self.center[2])**2)
        y = r/self.a

        val = 0
        val = 2*self.Qn[0]*(1-y**2)/(pi*self.a**2)

        for n in range(1, self.N):
            add = exp(1j*self.omega*n*self.t)
            add *= self.Qn[n]/(pi*self.a**2)
            add *= (1-jn(0, self.beta[n]*y)/self.jn0_betas[n])/(1-2*self.jn1_betas[n]/(self.beta[n]*self.jn0_betas[n]))

            #*(self.Qn[n]/(pi*self.a**2))*(self.jn0_betas[n]-jn(0, self.beta[n]*y))/(self.beta[n]*self.jn0_betas[n]-2*self.jn1_betas[n])

            val += add
        val = val.real

        value[0] = -self.normal_component*self.scale_value*val
	
	t2 = time()



class Womersley(BC_base, list):
    '''
    Generates a list of expressions in the form of a Womersley profile.
    '''
    #def __init__(self, coeffs, mesh, indicator, method='peak', scale_value=None, scale_mode='flux'):
    #def __init__(self, coeffs, mesh, indicator, nu, scale_value=None, scale_mode='flux'):
    def __init__(self, coeffs, mesh, indicator, nu, scale_to=None):
        assert(isinstance(mesh, Mesh))

        self.mesh = mesh
        self.ind = indicator

        # Find radius and center
        A, center = area_and_center(mesh, self.ind)
        radius = sqrt(A/pi)

        # Get normal
        normal = find_average_normal(mesh, self.ind)

        # Coefficients of velocity profile
        x,y = zip(*coeffs)
        x = array(x)
        y = array(y)

        self.period = max(x)

        # Get a highly resolved function of the input by linear interpolation
        f = UnivariateSpline(x,y,k=1, s=0)
        xx = linspace(0,self.period, 1001)

        Qn = fourier_coefficients(xx, f, self.period)

        # Create Expressions
        for i in range(3):
            args = {"normal_component": normal[i], "radius": radius, "center": center, "Qn": Qn, "period": self.period, "nu": nu}
            self.append(_WomersleyExpression(args))
        
        if scale_to is not None:
            scale_factor = self.scale(scale_to)
            for e in self: e._set_scale_value(scale_factor)
                
            

    def get_scale_value(self, scale_value, scale_mode, degree):
        # TODO: Fix scale value.
        if scale_value == None:
            return 1.0
        if scale_mode != "flux":
            raise NotImplementedError("Scale mode %s has not been implemented" %scale_mode)

        V = VectorFunctionSpace(self.mesh, "CG", degree)
        u = Function(V)

        qt = []
        for t in linspace(0, self.period, 100):
            for e in self:
                e.set_t(t)

            expr = VectorExpression(self[0], self[1], self[2])

            bc = DirichletBC(V, expr, self.ind)
            bc.apply(u.vector())

            n = FacetNormal(self.mesh)
            qt.append(assemble(dot(u,n)*ds(self.ind)))
            print qt[-1]
        q_avg = sum(qt)/len(qt)
        scale_value = scale_value/q_avg
        return scale_value
