
from ..dol import *

import numpy as np
from scipy.interpolate import UnivariateSpline
from itertools import izip
from .bcutils import get_area, get_center, get_average_normal, compute_transient_scale_value

class _PouseilleExpression(Expression):
    # Subclassing the expression class restricts the number of arguments, args is therefore a dict of arguments.
    def __init__(self, args): # TODO: Document args properly
        Expression.__init__(self)

        # Spatial args
        self.radius = args["radius"]
        self.center = args["center"]
        self.normal_component = args["normal_component"]

        # Temporal args
        self.period = args["period"]
        # FIXME: Remove this temporary hack, here to allow external problems to be updated smoothly:
        if "velocity_profile" in args:
            print "NB! 'velocity_profile' is deprecated, renamed to transient_profile!"
            self.transient_profile = args["velocity_profile"]
        else:
            self.transient_profile = args["transient_profile"]

        # Internal state
        self.t = 0.0
        self.scale_value = 1.0

    def set_t(self, t):
        self.t = t % self.period

    def eval(self, value, x):
        # Compute scalar velocity profile value in flow direction
        r2 = sum((xi-ci)**2 for xi,ci in izip(x,self.center))
        y2 = r2 / self.radius**2
        velocity_profile = (1 - y2)

        # Scale by transient profile
        val = self.transient_profile(self.t) * velocity_profile

        # Output scaled value for this negative normal direction
        value[0] = -self.scale_value * self.normal_component * val


class Pouseille(list):
    '''
    Generates a list of expressions in the form of a Pouseille/parabolic profile.
    '''
    #def __init__(self, coeffs, mesh, indicator, method='peak', scale_value=None, scale_mode='flux', segregated=False):
    def __init__(self, coeffs, mesh, indicator, scale_to=None, facet_domains=None):
        assert(isinstance(mesh, Mesh))

        # TODO: Always require facet_domains
        if facet_domains is None:
            dim = mesh.geometry().dim()
            facet_domains = MeshFunction("size_t", mesh, dim-1, mesh.domains())
            assert facet_domains is not None, "Missing facet domains!"

        # Compute radius, center and normal vector
        area = get_area(mesh, indicator, facet_domains)
        radius = np.sqrt(area / pi)
        center = get_center(mesh, indicator, facet_domains)
        normal = get_average_normal(mesh, indicator, facet_domains)

        # Compute transient profile as interpolation of given coefficients
        x,y = zip(*coeffs)
        x = np.array(x)
        y = np.array(y)
        period = max(x)
        transient_profile = UnivariateSpline(x, y, s=0, k=1)

        # Create Expressions for each direction
        expressions = []
        for ncomp in normal:
            args = {
                "radius": radius,
                "center": center,
                "normal_component": ncomp,
                "period": period,
                "transient_profile": transient_profile,
                }
            expressions.append(_PouseilleExpression(args))

        # Apply scaling w.r.t. peak transient profile (FIXME: This is unclear!)
        if scale_to is not None:
            scale_factor = compute_transient_scale_value(expressions, period,
                                                         mesh, facet_domains, indicator,
                                                         scale_value)
            for e in expressions:
                e.scale_value = scale_factor

        # TODO: Don't need this class, just make it a function to return expressions instead
        #self.mesh = mesh
        #self.ind = indicator
        #self.facet_domains = facet_domains
        #self.period = period
        self.extend(expressions)
