
from ..dol import *

import numpy as np
from scipy.interpolate import UnivariateSpline

from .bcutils import get_area, get_center, get_average_normal, compute_transient_scale_value

class _PouseilleExpression(Expression):
    # Subclassing the expression class restricts the number of arguments, args is therefore a dict of arguments.
    def __init__(self, args): # TODO: Document args properly
        Expression.__init__(self)

        # Spatial args
        self.radius = args["radius"]
        self.center = args["center"]
        self.normal_component = args["normal_component"]

        # Temporal args
        self.period = args["period"]
        # FIXME: Temporary hack to allow external problems to be updated smoothly:
        if "velocity_profile" in args:
            print "NB! 'velocity_profile' is deprecated, renamed to transient_profile!"
            self.transient_profile = args["velocity_profile"]
        else:
            self.transient_profile = args["transient_profile"]

        # Internal state
        self.t = 0.0
        self.scale_value = 1.0

    def set_t(self, t):
        self.t = t % self.period

    def eval(self, value, x):
        # Compute scalar value in flow direction
        c = self.center
        d = len(c)
        r2 = sum((x[i]-c[i])**2 for i in xrange(d))
        y2 = r2 / self.radius**2
        val = self.transient_profile(self.t) * (1 - y2)

        # Output scaled value for this negative normal direction
        value[0] = -self.scale_value * self.normal_component * val


class Pouseille(list):
    '''
    Generates a list of expressions in the form of a Pouseille/parabolic profile.
    '''
    #def __init__(self, coeffs, mesh, indicator, method='peak', scale_value=None, scale_mode='flux', segregated=False):
    def __init__(self, coeffs, mesh, indicator, scale_to=None, facet_domains=None):
        assert(isinstance(mesh, Mesh))

        # TODO: Always require facet_domains
        if facet_domains is None:
            dim = mesh.geometry().dim()
            facet_domains = MeshFunction("size_t", mesh, dim-1, mesh.domains())
            assert facet_domains is not None, "Missing facet domains!"

        # Find radius and center
        A = get_area(mesh, indicator, facet_domains)
        center = get_center(mesh, indicator, facet_domains)
        radius = np.sqrt(A/pi)

        # Get normal
        normal = get_average_normal(mesh, indicator, facet_domains)

        # Find velocity profile
        x,y = zip(*coeffs)
        x = np.array(x)
        y = np.array(y)

        transient_profile = UnivariateSpline(x, y, s=0, k=1)

        period = max(x)

        # Create Expressions
        d = len(normal)
        expressions = []
        for i in xrange(d):
            args = {
                "normal_component": normal[i],
                "radius": radius,
                "center": center,
                "transient_profile": transient_profile,
                "period": period,
                }
            expressions.append(_PouseilleExpression(args))

        if scale_to is not None:
            scale_factor = compute_transient_scale_value(expressions, period,
                                                         mesh, facet_domains, indicator,
                                                         scale_value)
            for e in expressions:
                e.scale_value = scale_factor

        # TODO: Don't need this class, just make it a function to return expressions instead
        #self.mesh = mesh
        #self.ind = indicator
        #self.facet_domains = facet_domains
        #self.period = period
        self.extend(expressions)
